{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/instagram.js","path":"js/instagram.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/mobile.js","path":"js/mobile.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/pc.js","path":"js/pc.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/coderwall.png","path":"img/coderwall.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/delicious.png","path":"img/delicious.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/douban.png","path":"img/douban.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/facebook.png","path":"img/facebook.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/github.png","path":"img/github.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/google.png","path":"img/google.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/img-err.png","path":"img/img-err.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/img-loading.png","path":"img/img-loading.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/linkedin.png","path":"img/linkedin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/mail.png","path":"img/mail.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/pinboard.png","path":"img/pinboard.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/pinterest.png","path":"img/pinterest.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/rss.png","path":"img/rss.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/twitter.png","path":"img/twitter.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/weibo.png","path":"img/weibo.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/zhihu.png","path":"img/zhihu.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","path":"css/fonts/fontawesome-webfont.svgz","modified":0,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/yilia/README.md","hash":"8648a81b3ae08a4accd6b0541533e662511e6400","modified":1464972666613},{"_id":"themes/yilia/.gitignore","hash":"0d5c2fdbdc974f10150baa12e1fc171a34960ed8","modified":1464972666612},{"_id":"themes/yilia/_config.yml","hash":"e15c42c756abb79b399d49602f978dc3569c85fe","modified":1464979546691},{"_id":"themes/yilia/package.json","hash":"0199dfb3d44cf520b67464817d13c44a7766b8d6","modified":1464972666680},{"_id":"themes/yilia/languages/de.yml","hash":"bc80f78f61c3d7af9652e6aa6fc3e4ff39b0c8d3","modified":1464972666618},{"_id":"themes/yilia/languages/default.yml","hash":"f0a7a032b31555c9ec05a711e1ac19bb07724708","modified":1464972666619},{"_id":"themes/yilia/languages/en.yml","hash":"a093e794aef63ec9e9e9ef490cf7e4474e45e59f","modified":1464972666621},{"_id":"themes/yilia/languages/fr-FR.yml","hash":"04b9a0d80d88d01e039e8077afe88f741e9620ba","modified":1464972666622},{"_id":"themes/yilia/languages/ru.yml","hash":"62f84ea82a696060c481fc22d4742e6201bb9bdc","modified":1464972666623},{"_id":"themes/yilia/languages/zh-Hans.yml","hash":"d2336578e14bb880d152266981c2b17523fc8742","modified":1464972666626},{"_id":"themes/yilia/languages/zh-hk.yml","hash":"e702fc43556e54c396917bdf7c869d528742e28b","modified":1464972666629},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"005559baa96b7bb34e1efe6b031829a95d58d5e0","modified":1464972666630},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1464972666668},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1464972666669},{"_id":"themes/yilia/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1464972666670},{"_id":"themes/yilia/layout/layout.ejs","hash":"3a4350f23a1286345f76c949466c97a7200dae8e","modified":1464972666672},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1464972666674},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1464972666677},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1464972666679},{"_id":"source/about/index.md","hash":"12321ac39ed16e3cd39339bb08c2741f9cbe117a","modified":1464980639444},{"_id":"source/_posts/VBdotNET_howto.md","hash":"0a3585da94ce483bd10b274a463036a16988d1ab","modified":1464982022644},{"_id":"source/_posts/nodejs.md","hash":"dab27255231827531e15caed4674a4bf2c83d2b3","modified":1464981919124},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"3709af4e8f7e1196dbd1f9dea62fa440d4b47836","modified":1464972666633},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"5b29a383418cfdcf8d5c5719b4fc4608aaba6fe7","modified":1464972666635},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1464972666637},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"420b94c78832456686ebd9831a5bfcb05365645a","modified":1464972666638},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"871f81cacd5d41cb2eb001cd56254217a857dc2f","modified":1464972666640},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1464972666642},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"2bbf5aad03f54055d9d7852e70ff7e6952a41f26","modified":1464972666644},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1464972666646},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"b03e8424b4798d4887801afdfae457fbf6027838","modified":1464972666648},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"7be03a92dabeb2f94bf0e731d12a1c1146d736dd","modified":1464972666649},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"6a7a2a4960dabf9d7cd523573da7869eebf4b02d","modified":1464972666651},{"_id":"themes/yilia/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1464972666683},{"_id":"themes/yilia/source/css/_variables.styl","hash":"8b63ea3c7199524b9a1541075c6f8fb2c0d0ea3d","modified":1464972666715},{"_id":"themes/yilia/source/css/style.styl","hash":"456e8cfe3b0b0371e81848ea9b0bc7ffd5360921","modified":1464972666731},{"_id":"themes/yilia/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1464972666734},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1464972666736},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1464972666740},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1464972666738},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1464972666742},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1464972666745},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","hash":"96138eaddfbd305160ddcb98a5f08555ca6cb4ee","modified":1464972666759},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","hash":"004bb0812414554ab48067792f09e978603253b6","modified":1464972666763},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1464972666765},{"_id":"themes/yilia/source/js/instagram.js","hash":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1464972666801},{"_id":"themes/yilia/source/js/jquery.lazyload.js","hash":"9c34c37b4dca82386648d364da913153d1db902e","modified":1464972666803},{"_id":"themes/yilia/source/js/main.js","hash":"e2633f282e377a4169649c9f17dc96036ad4fc64","modified":1464972666805},{"_id":"themes/yilia/source/js/mobile.js","hash":"387c047e661f04fbb5f5bfc4b2db617023e836ce","modified":1464972666807},{"_id":"themes/yilia/source/js/pc.js","hash":"a5397d34a04084ee089b4b1e26457ab46ecea63e","modified":1464972666810},{"_id":"themes/yilia/source/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1464972666767},{"_id":"themes/yilia/source/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1464972666770},{"_id":"themes/yilia/source/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1464972666772},{"_id":"themes/yilia/source/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1464972666773},{"_id":"themes/yilia/source/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1464972666776},{"_id":"themes/yilia/source/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1464972666778},{"_id":"themes/yilia/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1464972666780},{"_id":"themes/yilia/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1464972666781},{"_id":"themes/yilia/source/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1464972666784},{"_id":"themes/yilia/source/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1464972666785},{"_id":"themes/yilia/source/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1464972666786},{"_id":"themes/yilia/source/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1464972666788},{"_id":"themes/yilia/source/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1464972666789},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1464972666791},{"_id":"themes/yilia/source/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1464972666793},{"_id":"themes/yilia/source/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1464972666795},{"_id":"themes/yilia/source/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1464972666797},{"_id":"themes/yilia/source/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1464972666798},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"27fab3e6ccc41c075dc4c5ba3ca9e7f3b6247945","modified":1464972666653},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"06d8914b5aef73b5ec2cabb0105e275ff821b321","modified":1464972666654},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1464972666656},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"c115c282eebfb6b18612d2d8733272c270b03066","modified":1464972666658},{"_id":"themes/yilia/layout/_partial/post/share_addthis.ejs","hash":"4ab6cab2a975a4df8419448b33dec4724279d85c","modified":1464972666661},{"_id":"themes/yilia/layout/_partial/post/share_jia.ejs","hash":"d50294bf9858e7942208c380e851a37ed37f1d6f","modified":1464972666663},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"acf1b9d79ccec172881f9f0080e96667f4178885","modified":1464972666665},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1464972666666},{"_id":"themes/yilia/source/css/_partial/archive.styl","hash":"8b349f1605024dcdae054e04f02d71a2e84957c2","modified":1464972666686},{"_id":"themes/yilia/source/css/_partial/article.styl","hash":"872fc4e63509fef885c939e5fd70e6ed439beced","modified":1464972666688},{"_id":"themes/yilia/source/css/_partial/footer.styl","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1464972666689},{"_id":"themes/yilia/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1464972666691},{"_id":"themes/yilia/source/css/_partial/highlight.styl","hash":"08d3205dde3235f3e6881126268e6c473f46a8ac","modified":1464972666694},{"_id":"themes/yilia/source/css/_partial/main.styl","hash":"c368f1533053d4cffdf0ad982603271400b08e33","modified":1464972666698},{"_id":"themes/yilia/source/css/_partial/mobile-slider.styl","hash":"e19c7fae6968ad3ea6cfc110900a991f9b5fce31","modified":1464972666699},{"_id":"themes/yilia/source/css/_partial/instagram.styl","hash":"8a7b07bf5ea2d3588c0019f722c245bb1a8696af","modified":1464972666696},{"_id":"themes/yilia/source/css/_partial/mobile.styl","hash":"3a03b04ef8ac305aa5dbf7b9db99cd9377d07383","modified":1464972666701},{"_id":"themes/yilia/source/css/_partial/page.styl","hash":"720b5b169bc28ccba3794efce9b7cd39f243dec7","modified":1464972666703},{"_id":"themes/yilia/source/css/_partial/scroll.styl","hash":"5539a38f9acd603d453a0ea0d8ce10893cf83d22","modified":1464972666704},{"_id":"themes/yilia/source/css/_partial/share.styl","hash":"22697b9a9877ab9f018364feb57aeea4a8313c9a","modified":1464972666705},{"_id":"themes/yilia/source/css/_partial/tagcloud.styl","hash":"af0115de5c6455f899a2e09225b50224982c039d","modified":1464972666707},{"_id":"themes/yilia/source/css/_partial/wheelmenu.styl","hash":"9e57421eab562ea13d0ed2b2e1415eee79fa23d0","modified":1464972666709},{"_id":"themes/yilia/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1464972666712},{"_id":"themes/yilia/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1464972666714},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","hash":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1464972666719},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","hash":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1464972666727},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","hash":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1464972666724},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","hash":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1464972666729},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1464972666748},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1464972666750},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1464972666752},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1464972666754},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1464972666755},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1464972666757},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","hash":"ba13657479b46daecb6336bfe376f84cef3ae58b","modified":1464972666722},{"_id":"public/archives/index.html","hash":"877173fb819643a34340c12924a59547c1241bad","modified":1464982082786},{"_id":"public/archives/2016/index.html","hash":"a232785072945cff76404ea2da1bcf32c633509c","modified":1464982082787},{"_id":"public/archives/2016/06/index.html","hash":"92d54ddbdeb60fb0feece193b81437c9b243efb8","modified":1464982082788},{"_id":"public/tags/VB-NET/index.html","hash":"b2cbcce03683addaf69576672e9254e27a6fe868","modified":1464982082788},{"_id":"public/tags/转载搬运/index.html","hash":"a93313805bc2d03146feb6bdbe05cab658efe0c7","modified":1464982082788},{"_id":"public/tags/nodejs/index.html","hash":"4501952809069660886d5cf14eaeaabaef00f806","modified":1464982082788},{"_id":"public/about/index.html","hash":"aa915db9a54a2e95eac3630e4387052dab41b3a6","modified":1464982082789},{"_id":"public/2016/06/04/VBdotNET_howto/index.html","hash":"4e2a43aa84255137625695b2562d6fc92db0a86e","modified":1464982082789},{"_id":"public/2016/06/04/nodejs/index.html","hash":"2f30f2a1bc01260578e90f0871ce13fd1fec572f","modified":1464982082789},{"_id":"public/index.html","hash":"aebeb3f016227a53a6cc2c2df47478795a11458a","modified":1464982082790},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1464982082859},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1464982082860},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1464982082863},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1464982082860},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1464982082862},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1464982082861},{"_id":"public/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1464982082864},{"_id":"public/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1464982082865},{"_id":"public/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1464982082864},{"_id":"public/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1464982082865},{"_id":"public/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1464982082864},{"_id":"public/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1464982082866},{"_id":"public/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1464982082866},{"_id":"public/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1464982082866},{"_id":"public/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1464982082865},{"_id":"public/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1464982082867},{"_id":"public/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1464982082867},{"_id":"public/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1464982082867},{"_id":"public/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1464982082867},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1464982082867},{"_id":"public/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1464982082867},{"_id":"public/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1464982082867},{"_id":"public/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1464982082867},{"_id":"public/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1464982082868},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1464982082867},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1464982082868},{"_id":"public/css/fonts/fontawesome-webfont.svgz","hash":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1464982082868},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1464982082868},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1464982082868},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"ba13657479b46daecb6336bfe376f84cef3ae58b","modified":1464982084911},{"_id":"public/fancybox/jquery.fancybox.css","hash":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20","modified":1464982084929},{"_id":"public/js/instagram.js","hash":"f19adbcc0dac33536bc6660598059048ec901882","modified":1464982084929},{"_id":"public/js/jquery.lazyload.js","hash":"c11a2e7b330d16d06feabd0a8477099adf9d6799","modified":1464982084929},{"_id":"public/js/main.js","hash":"0640b68a76fab3c693b3cd1e4d04d14be1e53940","modified":1464982084929},{"_id":"public/js/mobile.js","hash":"b68cc01d24e80973c48205f551da87f3f3427644","modified":1464982084929},{"_id":"public/js/pc.js","hash":"fdbc039fc9ffa70815b5fc4daaa587ae29693f10","modified":1464982084929},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1464982084930},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1464982084930},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1464982084929},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1464982084930},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1464982084930},{"_id":"public/css/style.css","hash":"10e9b93cf935a165020e48334a40b84b0f895401","modified":1464982084930},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1464982084930},{"_id":"public/fancybox/jquery.fancybox.js","hash":"a82597493d75ea989ca586e09173cff332efe41e","modified":1464982084930}],"Category":[],"Data":[],"Page":[{"title":"谢桂纲的个人简历","date":"1989-10-01T18:43:32.000Z","_content":"\n## 联系方式\n+ 个人邮箱:  [xie.guigang@gmail.com](mailto://xie.guigang@gmail.com)\n+ 工作邮箱:\n   + [xie.guigang@gcmodeller.org](mailto://xie.guigang@gcmodeller.org)\n   + [admin-master@gcmodeller.org](mailto://admin-master@gcmodeller.org)\n+ 手机: +86 13807837047\n+ github社区主页: [https://github.com/xieguigang](https://github.com/xieguigang)\n\n他自称是一名全栈开发人员，但是其实主要精通的是进行服务器后端的开发工作，对于前端的html5开发也略微精通。其从2011年开始学习编程，从2013年开始算起到现在已经有3年的服务器后端的开发经验了。他在位于美国的西雅图微软公司的雷德蒙德研究院有过为期1个月的学习实习经历。\n\n**他是一名开源项目的狂热份子，热衷于开源项目的开发。其目前主要活跃于国外的github社区以及作为codeproject社区的文章审稿人活跃于当前的最大的.NET开源社区之上。**目前正在学习d3js和html5，正在进行GCModeller项目的在线服务平台的前端开发工作。\n\n## 主要使用的开发语言和环境\n+ VisualBasic.NET, R, Perl, Bash, ShoalShell(自己开发的用于调试GCModeller计算引擎的脚本语言)\n+ 数据分析： Bioconductor, GCModeller\n+ 数据可视化: d3js, Circos\n\n## **私人科研项目**\n### 1. GCModeller开放计算平台 (VB.NET)\n> **开发时间**\t2013.08 - 至今<br />\n> **项目主页**\thttp://gcmodeller.org<br />\n> **在线服务**\thttp://services.gcmodeller.org/\n\nGCModeller主要提供了一系列的免费开源工具用于进行原核生物的全基因组的生物网络系统模块的注释建模以及计算数据分析。目前GCModeller主要为国内外的大学以及生物测序公司提供收费的服务支持和数据分析服务。\n\n当前已经开发完成的比较成熟的分析功能模块有：\n>1.\t基于序列特征的全基因组的基因表达调控网络的构建工具；\n2.\tRNA-Seq数据分析套件；\n3.\tFBA细胞表型分析套件；\n4.\t细胞网络可视化套件与基因组可视化组件；\n5.\t大规模序列比对LocalBLAST/Clustal分析套件；\n6.\t生物数据挖掘分析组件。\n\nGCModeller项目目前正在申请**美国微软公司Microsoft .NET Foundation开源基金会**资助项目，GCModeller项目目前是继微软的西雅图雷德蒙德研究院MBF项目之后的.NET平台上面的第二大生物信息学分析项目。\n\n\n**这里列出了基于GCModeller的数据分析服务的SCI论文列表：**\n>1. *__Niu XN etc__. Complete sequence and detailed analysis of the first indigenous plasmid from Xanthomonas oryzae pv. Oryzicola* (**doi:** [10.1186/s12866-015-0562-x](http://bmcmicrobiol.biomedcentral.com/articles/10.1186/s12866-015-0562-x))\n\n### 2. GCModeller分布式计算服务器集群环境 (VB.NET)\n> **开发时间**\t2016.03 - 至今<br />\n> **项目主页**  https://github.com/xieguigang/Microsoft.VisualBasic.Parallel<br />\n> **CodeProject知识库文章** [\"Easy Distribution Computing in VisualBasic\"](http://www.codeproject.com/Articles/1076209/Easy-Distribution-Computing-in-VisualBasic)\n\n本分布式计算环境是GCModeller计算系统的在线服务模块的组件之一，目标是构建一个高性能的在线分析计算平台。\n\n-------------------------\n### **谢桂纲的CodeProject社区文章列表**\n1. [R Statics Language API to VB.NET Language](http://www.codeproject.com/Articles/1083875/R-Statics-Language-API-to-VB-NET-Language)\n2. [Venn Diagram in VisualBasic](http://www.codeproject.com/Articles/1090178/Venn-Diagram-in-VisualBasic)\n3. [R language S4Object Serialization to .NET Object](http://www.codeproject.com/Articles/890099/R-language-S-Object-Serialization-to-NET-Object)\n4. [Code style guidelines for Microsoft VisualBasic](http://www.codeproject.com/Articles/1101608/Code-style-guidelines-for-Microsoft-VisualBasic)\n5. [Easy Document in VisualBasic](http://www.codeproject.com/Articles/1099296/Easy-Document-in-VisualBasic)\n6. [Guide line of integrated ShellScript with R Hybrid programming](http://www.codeproject.com/Articles/832975/Guide-line-of-integrated-ShellScript-with-R-Hybrid)\n7. [Auto-Generated visual basic source code from SQL](http://www.codeproject.com/Articles/989264/Auto-Generated-visual-basic-source-code-from-SQL)\n8. [Visual Basic Using Reflection to Map DataTable in MySQL Database](http://www.codeproject.com/Articles/638976/Visual-Basic-Using-Reflection-to-Map-DataTable-in)\n9. [LINQ Script: A Universal Object-Oriented Database Query Language](http://www.codeproject.com/Articles/721827/LINQ-Script-A-Universal-Object-Oriented-Database-Q)\n10. [A complex Mathematics expression evaluation module in Visual Basic](http://www.codeproject.com/Articles/646391/A-complex-Mathematics-expression-evaluation-module)\n11. [VisualBasic Machine Learning, Step 1: The Q-Learning](http://www.codeproject.com/Articles/1088282/VisualBasic-Machine-Learning-Step-The-Q-Learning)\n12. [Modeling the Biochemical System Using VB](http://www.codeproject.com/Articles/664153/Modeling-the-Biochemical-System-Using-VB)\n13. [Powerful ShellScript for bioinformatics researchers](http://www.codeproject.com/Articles/820854/Powerful-ShellScript-for-bioinformatics-researcher)\n14. [Draw sequence logo](http://www.codeproject.com/Articles/1095279/Draw-sequence-logo)\n15. [Easy Distribution Computing in VisualBasic](http://www.codeproject.com/Articles/1076209/Easy-Distribution-Computing-in-VisualBasic)\n16. [Simple HTTP Server in VisualBasic](http://www.codeproject.com/Articles/1068466/Simple-HTTP-Server-in-VisualBasic)\n17. [A powerful CSV document wrapper library](http://www.codeproject.com/Articles/788006/A-powerful-CSV-document-wrapper-library)\n18. [Develop a Plugin extension for your VisualBasic application](http://www.codeproject.com/Articles/703590/Develop-a-Plugin-extension-for-your-VisualBasic-ap)\n19. [Levenshtein Edit Distance [Technical Blog]](http://www.codeproject.com/Articles/1055849/Levenshtein-Edit-Distance)\n20. [Generate Color Mappings on Circos plot for prokaryote comparative genomics [Technical Blog]](http://www.codeproject.com/Articles/1055851/Generate-Color-Mappings-on-Circos-plot-for-prokary)","source":"about/index.md","raw":"---\ntitle: 谢桂纲的个人简历\ndate: 1989-10-02 02:43:32\n---\n\n## 联系方式\n+ 个人邮箱:  [xie.guigang@gmail.com](mailto://xie.guigang@gmail.com)\n+ 工作邮箱:\n   + [xie.guigang@gcmodeller.org](mailto://xie.guigang@gcmodeller.org)\n   + [admin-master@gcmodeller.org](mailto://admin-master@gcmodeller.org)\n+ 手机: +86 13807837047\n+ github社区主页: [https://github.com/xieguigang](https://github.com/xieguigang)\n\n他自称是一名全栈开发人员，但是其实主要精通的是进行服务器后端的开发工作，对于前端的html5开发也略微精通。其从2011年开始学习编程，从2013年开始算起到现在已经有3年的服务器后端的开发经验了。他在位于美国的西雅图微软公司的雷德蒙德研究院有过为期1个月的学习实习经历。\n\n**他是一名开源项目的狂热份子，热衷于开源项目的开发。其目前主要活跃于国外的github社区以及作为codeproject社区的文章审稿人活跃于当前的最大的.NET开源社区之上。**目前正在学习d3js和html5，正在进行GCModeller项目的在线服务平台的前端开发工作。\n\n## 主要使用的开发语言和环境\n+ VisualBasic.NET, R, Perl, Bash, ShoalShell(自己开发的用于调试GCModeller计算引擎的脚本语言)\n+ 数据分析： Bioconductor, GCModeller\n+ 数据可视化: d3js, Circos\n\n## **私人科研项目**\n### 1. GCModeller开放计算平台 (VB.NET)\n> **开发时间**\t2013.08 - 至今<br />\n> **项目主页**\thttp://gcmodeller.org<br />\n> **在线服务**\thttp://services.gcmodeller.org/\n\nGCModeller主要提供了一系列的免费开源工具用于进行原核生物的全基因组的生物网络系统模块的注释建模以及计算数据分析。目前GCModeller主要为国内外的大学以及生物测序公司提供收费的服务支持和数据分析服务。\n\n当前已经开发完成的比较成熟的分析功能模块有：\n>1.\t基于序列特征的全基因组的基因表达调控网络的构建工具；\n2.\tRNA-Seq数据分析套件；\n3.\tFBA细胞表型分析套件；\n4.\t细胞网络可视化套件与基因组可视化组件；\n5.\t大规模序列比对LocalBLAST/Clustal分析套件；\n6.\t生物数据挖掘分析组件。\n\nGCModeller项目目前正在申请**美国微软公司Microsoft .NET Foundation开源基金会**资助项目，GCModeller项目目前是继微软的西雅图雷德蒙德研究院MBF项目之后的.NET平台上面的第二大生物信息学分析项目。\n\n\n**这里列出了基于GCModeller的数据分析服务的SCI论文列表：**\n>1. *__Niu XN etc__. Complete sequence and detailed analysis of the first indigenous plasmid from Xanthomonas oryzae pv. Oryzicola* (**doi:** [10.1186/s12866-015-0562-x](http://bmcmicrobiol.biomedcentral.com/articles/10.1186/s12866-015-0562-x))\n\n### 2. GCModeller分布式计算服务器集群环境 (VB.NET)\n> **开发时间**\t2016.03 - 至今<br />\n> **项目主页**  https://github.com/xieguigang/Microsoft.VisualBasic.Parallel<br />\n> **CodeProject知识库文章** [\"Easy Distribution Computing in VisualBasic\"](http://www.codeproject.com/Articles/1076209/Easy-Distribution-Computing-in-VisualBasic)\n\n本分布式计算环境是GCModeller计算系统的在线服务模块的组件之一，目标是构建一个高性能的在线分析计算平台。\n\n-------------------------\n### **谢桂纲的CodeProject社区文章列表**\n1. [R Statics Language API to VB.NET Language](http://www.codeproject.com/Articles/1083875/R-Statics-Language-API-to-VB-NET-Language)\n2. [Venn Diagram in VisualBasic](http://www.codeproject.com/Articles/1090178/Venn-Diagram-in-VisualBasic)\n3. [R language S4Object Serialization to .NET Object](http://www.codeproject.com/Articles/890099/R-language-S-Object-Serialization-to-NET-Object)\n4. [Code style guidelines for Microsoft VisualBasic](http://www.codeproject.com/Articles/1101608/Code-style-guidelines-for-Microsoft-VisualBasic)\n5. [Easy Document in VisualBasic](http://www.codeproject.com/Articles/1099296/Easy-Document-in-VisualBasic)\n6. [Guide line of integrated ShellScript with R Hybrid programming](http://www.codeproject.com/Articles/832975/Guide-line-of-integrated-ShellScript-with-R-Hybrid)\n7. [Auto-Generated visual basic source code from SQL](http://www.codeproject.com/Articles/989264/Auto-Generated-visual-basic-source-code-from-SQL)\n8. [Visual Basic Using Reflection to Map DataTable in MySQL Database](http://www.codeproject.com/Articles/638976/Visual-Basic-Using-Reflection-to-Map-DataTable-in)\n9. [LINQ Script: A Universal Object-Oriented Database Query Language](http://www.codeproject.com/Articles/721827/LINQ-Script-A-Universal-Object-Oriented-Database-Q)\n10. [A complex Mathematics expression evaluation module in Visual Basic](http://www.codeproject.com/Articles/646391/A-complex-Mathematics-expression-evaluation-module)\n11. [VisualBasic Machine Learning, Step 1: The Q-Learning](http://www.codeproject.com/Articles/1088282/VisualBasic-Machine-Learning-Step-The-Q-Learning)\n12. [Modeling the Biochemical System Using VB](http://www.codeproject.com/Articles/664153/Modeling-the-Biochemical-System-Using-VB)\n13. [Powerful ShellScript for bioinformatics researchers](http://www.codeproject.com/Articles/820854/Powerful-ShellScript-for-bioinformatics-researcher)\n14. [Draw sequence logo](http://www.codeproject.com/Articles/1095279/Draw-sequence-logo)\n15. [Easy Distribution Computing in VisualBasic](http://www.codeproject.com/Articles/1076209/Easy-Distribution-Computing-in-VisualBasic)\n16. [Simple HTTP Server in VisualBasic](http://www.codeproject.com/Articles/1068466/Simple-HTTP-Server-in-VisualBasic)\n17. [A powerful CSV document wrapper library](http://www.codeproject.com/Articles/788006/A-powerful-CSV-document-wrapper-library)\n18. [Develop a Plugin extension for your VisualBasic application](http://www.codeproject.com/Articles/703590/Develop-a-Plugin-extension-for-your-VisualBasic-ap)\n19. [Levenshtein Edit Distance [Technical Blog]](http://www.codeproject.com/Articles/1055849/Levenshtein-Edit-Distance)\n20. [Generate Color Mappings on Circos plot for prokaryote comparative genomics [Technical Blog]](http://www.codeproject.com/Articles/1055851/Generate-Color-Mappings-on-Circos-plot-for-prokary)","updated":"2016-06-03T19:03:59.444Z","path":"about/index.html","_id":"cip02xkqf00006sv40cwnpymc","comments":1,"layout":"page","content":"<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><ul>\n<li>个人邮箱:  <a href=\"mailto://xie.guigang@gmail.com\" target=\"_blank\" rel=\"external\">xie.guigang@gmail.com</a></li>\n<li>工作邮箱:<ul>\n<li><a href=\"mailto://xie.guigang@gcmodeller.org\" target=\"_blank\" rel=\"external\">xie.guigang@gcmodeller.org</a></li>\n<li><a href=\"mailto://admin-master@gcmodeller.org\" target=\"_blank\" rel=\"external\">admin-master@gcmodeller.org</a></li>\n</ul>\n</li>\n<li>手机: +86 13807837047</li>\n<li>github社区主页: <a href=\"https://github.com/xieguigang\" target=\"_blank\" rel=\"external\">https://github.com/xieguigang</a></li>\n</ul>\n<p>他自称是一名全栈开发人员，但是其实主要精通的是进行服务器后端的开发工作，对于前端的html5开发也略微精通。其从2011年开始学习编程，从2013年开始算起到现在已经有3年的服务器后端的开发经验了。他在位于美国的西雅图微软公司的雷德蒙德研究院有过为期1个月的学习实习经历。</p>\n<p><strong>他是一名开源项目的狂热份子，热衷于开源项目的开发。其目前主要活跃于国外的github社区以及作为codeproject社区的文章审稿人活跃于当前的最大的.NET开源社区之上。</strong>目前正在学习d3js和html5，正在进行GCModeller项目的在线服务平台的前端开发工作。</p>\n<h2 id=\"主要使用的开发语言和环境\"><a href=\"#主要使用的开发语言和环境\" class=\"headerlink\" title=\"主要使用的开发语言和环境\"></a>主要使用的开发语言和环境</h2><ul>\n<li>VisualBasic.NET, R, Perl, Bash, ShoalShell(自己开发的用于调试GCModeller计算引擎的脚本语言)</li>\n<li>数据分析： Bioconductor, GCModeller</li>\n<li>数据可视化: d3js, Circos</li>\n</ul>\n<h2 id=\"私人科研项目\"><a href=\"#私人科研项目\" class=\"headerlink\" title=\"私人科研项目\"></a><strong>私人科研项目</strong></h2><h3 id=\"1-GCModeller开放计算平台-VB-NET\"><a href=\"#1-GCModeller开放计算平台-VB-NET\" class=\"headerlink\" title=\"1. GCModeller开放计算平台 (VB.NET)\"></a>1. GCModeller开放计算平台 (VB.NET)</h3><blockquote>\n<p><strong>开发时间</strong>    2013.08 - 至今<br><br><strong>项目主页</strong>    <a href=\"http://gcmodeller.org\" target=\"_blank\" rel=\"external\">http://gcmodeller.org</a><br><br><strong>在线服务</strong>    <a href=\"http://services.gcmodeller.org/\" target=\"_blank\" rel=\"external\">http://services.gcmodeller.org/</a></p>\n</blockquote>\n<p>GCModeller主要提供了一系列的免费开源工具用于进行原核生物的全基因组的生物网络系统模块的注释建模以及计算数据分析。目前GCModeller主要为国内外的大学以及生物测序公司提供收费的服务支持和数据分析服务。</p>\n<p>当前已经开发完成的比较成熟的分析功能模块有：</p>\n<blockquote>\n<ol>\n<li>基于序列特征的全基因组的基因表达调控网络的构建工具；</li>\n<li>RNA-Seq数据分析套件；</li>\n<li>FBA细胞表型分析套件；</li>\n<li>细胞网络可视化套件与基因组可视化组件；</li>\n<li>大规模序列比对LocalBLAST/Clustal分析套件；</li>\n<li>生物数据挖掘分析组件。</li>\n</ol>\n</blockquote>\n<p>GCModeller项目目前正在申请<strong>美国微软公司Microsoft .NET Foundation开源基金会</strong>资助项目，GCModeller项目目前是继微软的西雅图雷德蒙德研究院MBF项目之后的.NET平台上面的第二大生物信息学分析项目。</p>\n<p><strong>这里列出了基于GCModeller的数据分析服务的SCI论文列表：</strong></p>\n<blockquote>\n<ol>\n<li><em><strong>Niu XN etc</strong>. Complete sequence and detailed analysis of the first indigenous plasmid from Xanthomonas oryzae pv. Oryzicola</em> (<strong>doi:</strong> <a href=\"http://bmcmicrobiol.biomedcentral.com/articles/10.1186/s12866-015-0562-x\" target=\"_blank\" rel=\"external\">10.1186/s12866-015-0562-x</a>)</li>\n</ol>\n</blockquote>\n<h3 id=\"2-GCModeller分布式计算服务器集群环境-VB-NET\"><a href=\"#2-GCModeller分布式计算服务器集群环境-VB-NET\" class=\"headerlink\" title=\"2. GCModeller分布式计算服务器集群环境 (VB.NET)\"></a>2. GCModeller分布式计算服务器集群环境 (VB.NET)</h3><blockquote>\n<p><strong>开发时间</strong>    2016.03 - 至今<br><br><strong>项目主页</strong>  <a href=\"https://github.com/xieguigang/Microsoft.VisualBasic.Parallel\" target=\"_blank\" rel=\"external\">https://github.com/xieguigang/Microsoft.VisualBasic.Parallel</a><br><br><strong>CodeProject知识库文章</strong> <a href=\"http://www.codeproject.com/Articles/1076209/Easy-Distribution-Computing-in-VisualBasic\" target=\"_blank\" rel=\"external\">“Easy Distribution Computing in VisualBasic”</a></p>\n</blockquote>\n<p>本分布式计算环境是GCModeller计算系统的在线服务模块的组件之一，目标是构建一个高性能的在线分析计算平台。</p>\n<hr>\n<h3 id=\"谢桂纲的CodeProject社区文章列表\"><a href=\"#谢桂纲的CodeProject社区文章列表\" class=\"headerlink\" title=\"谢桂纲的CodeProject社区文章列表\"></a><strong>谢桂纲的CodeProject社区文章列表</strong></h3><ol>\n<li><a href=\"http://www.codeproject.com/Articles/1083875/R-Statics-Language-API-to-VB-NET-Language\" target=\"_blank\" rel=\"external\">R Statics Language API to VB.NET Language</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/1090178/Venn-Diagram-in-VisualBasic\" target=\"_blank\" rel=\"external\">Venn Diagram in VisualBasic</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/890099/R-language-S-Object-Serialization-to-NET-Object\" target=\"_blank\" rel=\"external\">R language S4Object Serialization to .NET Object</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/1101608/Code-style-guidelines-for-Microsoft-VisualBasic\" target=\"_blank\" rel=\"external\">Code style guidelines for Microsoft VisualBasic</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/1099296/Easy-Document-in-VisualBasic\" target=\"_blank\" rel=\"external\">Easy Document in VisualBasic</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/832975/Guide-line-of-integrated-ShellScript-with-R-Hybrid\" target=\"_blank\" rel=\"external\">Guide line of integrated ShellScript with R Hybrid programming</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/989264/Auto-Generated-visual-basic-source-code-from-SQL\" target=\"_blank\" rel=\"external\">Auto-Generated visual basic source code from SQL</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/638976/Visual-Basic-Using-Reflection-to-Map-DataTable-in\" target=\"_blank\" rel=\"external\">Visual Basic Using Reflection to Map DataTable in MySQL Database</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/721827/LINQ-Script-A-Universal-Object-Oriented-Database-Q\" target=\"_blank\" rel=\"external\">LINQ Script: A Universal Object-Oriented Database Query Language</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/646391/A-complex-Mathematics-expression-evaluation-module\" target=\"_blank\" rel=\"external\">A complex Mathematics expression evaluation module in Visual Basic</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/1088282/VisualBasic-Machine-Learning-Step-The-Q-Learning\" target=\"_blank\" rel=\"external\">VisualBasic Machine Learning, Step 1: The Q-Learning</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/664153/Modeling-the-Biochemical-System-Using-VB\" target=\"_blank\" rel=\"external\">Modeling the Biochemical System Using VB</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/820854/Powerful-ShellScript-for-bioinformatics-researcher\" target=\"_blank\" rel=\"external\">Powerful ShellScript for bioinformatics researchers</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/1095279/Draw-sequence-logo\" target=\"_blank\" rel=\"external\">Draw sequence logo</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/1076209/Easy-Distribution-Computing-in-VisualBasic\" target=\"_blank\" rel=\"external\">Easy Distribution Computing in VisualBasic</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/1068466/Simple-HTTP-Server-in-VisualBasic\" target=\"_blank\" rel=\"external\">Simple HTTP Server in VisualBasic</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/788006/A-powerful-CSV-document-wrapper-library\" target=\"_blank\" rel=\"external\">A powerful CSV document wrapper library</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/703590/Develop-a-Plugin-extension-for-your-VisualBasic-ap\" target=\"_blank\" rel=\"external\">Develop a Plugin extension for your VisualBasic application</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/1055849/Levenshtein-Edit-Distance\" target=\"_blank\" rel=\"external\">Levenshtein Edit Distance [Technical Blog]</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/1055851/Generate-Color-Mappings-on-Circos-plot-for-prokary\" target=\"_blank\" rel=\"external\">Generate Color Mappings on Circos plot for prokaryote comparative genomics [Technical Blog]</a></li>\n</ol>\n","excerpt":"","more":"<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><ul>\n<li>个人邮箱:  <a href=\"mailto://xie.guigang@gmail.com\">xie.guigang@gmail.com</a></li>\n<li>工作邮箱:<ul>\n<li><a href=\"mailto://xie.guigang@gcmodeller.org\">xie.guigang@gcmodeller.org</a></li>\n<li><a href=\"mailto://admin-master@gcmodeller.org\">admin-master@gcmodeller.org</a></li>\n</ul>\n</li>\n<li>手机: +86 13807837047</li>\n<li>github社区主页: <a href=\"https://github.com/xieguigang\">https://github.com/xieguigang</a></li>\n</ul>\n<p>他自称是一名全栈开发人员，但是其实主要精通的是进行服务器后端的开发工作，对于前端的html5开发也略微精通。其从2011年开始学习编程，从2013年开始算起到现在已经有3年的服务器后端的开发经验了。他在位于美国的西雅图微软公司的雷德蒙德研究院有过为期1个月的学习实习经历。</p>\n<p><strong>他是一名开源项目的狂热份子，热衷于开源项目的开发。其目前主要活跃于国外的github社区以及作为codeproject社区的文章审稿人活跃于当前的最大的.NET开源社区之上。</strong>目前正在学习d3js和html5，正在进行GCModeller项目的在线服务平台的前端开发工作。</p>\n<h2 id=\"主要使用的开发语言和环境\"><a href=\"#主要使用的开发语言和环境\" class=\"headerlink\" title=\"主要使用的开发语言和环境\"></a>主要使用的开发语言和环境</h2><ul>\n<li>VisualBasic.NET, R, Perl, Bash, ShoalShell(自己开发的用于调试GCModeller计算引擎的脚本语言)</li>\n<li>数据分析： Bioconductor, GCModeller</li>\n<li>数据可视化: d3js, Circos</li>\n</ul>\n<h2 id=\"私人科研项目\"><a href=\"#私人科研项目\" class=\"headerlink\" title=\"私人科研项目\"></a><strong>私人科研项目</strong></h2><h3 id=\"1-GCModeller开放计算平台-VB-NET\"><a href=\"#1-GCModeller开放计算平台-VB-NET\" class=\"headerlink\" title=\"1. GCModeller开放计算平台 (VB.NET)\"></a>1. GCModeller开放计算平台 (VB.NET)</h3><blockquote>\n<p><strong>开发时间</strong>    2013.08 - 至今<br /><br><strong>项目主页</strong>    <a href=\"http://gcmodeller.org\">http://gcmodeller.org</a><br /><br><strong>在线服务</strong>    <a href=\"http://services.gcmodeller.org/\">http://services.gcmodeller.org/</a></p>\n</blockquote>\n<p>GCModeller主要提供了一系列的免费开源工具用于进行原核生物的全基因组的生物网络系统模块的注释建模以及计算数据分析。目前GCModeller主要为国内外的大学以及生物测序公司提供收费的服务支持和数据分析服务。</p>\n<p>当前已经开发完成的比较成熟的分析功能模块有：</p>\n<blockquote>\n<ol>\n<li>基于序列特征的全基因组的基因表达调控网络的构建工具；</li>\n<li>RNA-Seq数据分析套件；</li>\n<li>FBA细胞表型分析套件；</li>\n<li>细胞网络可视化套件与基因组可视化组件；</li>\n<li>大规模序列比对LocalBLAST/Clustal分析套件；</li>\n<li>生物数据挖掘分析组件。</li>\n</ol>\n</blockquote>\n<p>GCModeller项目目前正在申请<strong>美国微软公司Microsoft .NET Foundation开源基金会</strong>资助项目，GCModeller项目目前是继微软的西雅图雷德蒙德研究院MBF项目之后的.NET平台上面的第二大生物信息学分析项目。</p>\n<p><strong>这里列出了基于GCModeller的数据分析服务的SCI论文列表：</strong></p>\n<blockquote>\n<ol>\n<li><em><strong>Niu XN etc</strong>. Complete sequence and detailed analysis of the first indigenous plasmid from Xanthomonas oryzae pv. Oryzicola</em> (<strong>doi:</strong> <a href=\"http://bmcmicrobiol.biomedcentral.com/articles/10.1186/s12866-015-0562-x\">10.1186/s12866-015-0562-x</a>)</li>\n</ol>\n</blockquote>\n<h3 id=\"2-GCModeller分布式计算服务器集群环境-VB-NET\"><a href=\"#2-GCModeller分布式计算服务器集群环境-VB-NET\" class=\"headerlink\" title=\"2. GCModeller分布式计算服务器集群环境 (VB.NET)\"></a>2. GCModeller分布式计算服务器集群环境 (VB.NET)</h3><blockquote>\n<p><strong>开发时间</strong>    2016.03 - 至今<br /><br><strong>项目主页</strong>  <a href=\"https://github.com/xieguigang/Microsoft.VisualBasic.Parallel\">https://github.com/xieguigang/Microsoft.VisualBasic.Parallel</a><br /><br><strong>CodeProject知识库文章</strong> <a href=\"http://www.codeproject.com/Articles/1076209/Easy-Distribution-Computing-in-VisualBasic\">“Easy Distribution Computing in VisualBasic”</a></p>\n</blockquote>\n<p>本分布式计算环境是GCModeller计算系统的在线服务模块的组件之一，目标是构建一个高性能的在线分析计算平台。</p>\n<hr>\n<h3 id=\"谢桂纲的CodeProject社区文章列表\"><a href=\"#谢桂纲的CodeProject社区文章列表\" class=\"headerlink\" title=\"谢桂纲的CodeProject社区文章列表\"></a><strong>谢桂纲的CodeProject社区文章列表</strong></h3><ol>\n<li><a href=\"http://www.codeproject.com/Articles/1083875/R-Statics-Language-API-to-VB-NET-Language\">R Statics Language API to VB.NET Language</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/1090178/Venn-Diagram-in-VisualBasic\">Venn Diagram in VisualBasic</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/890099/R-language-S-Object-Serialization-to-NET-Object\">R language S4Object Serialization to .NET Object</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/1101608/Code-style-guidelines-for-Microsoft-VisualBasic\">Code style guidelines for Microsoft VisualBasic</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/1099296/Easy-Document-in-VisualBasic\">Easy Document in VisualBasic</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/832975/Guide-line-of-integrated-ShellScript-with-R-Hybrid\">Guide line of integrated ShellScript with R Hybrid programming</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/989264/Auto-Generated-visual-basic-source-code-from-SQL\">Auto-Generated visual basic source code from SQL</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/638976/Visual-Basic-Using-Reflection-to-Map-DataTable-in\">Visual Basic Using Reflection to Map DataTable in MySQL Database</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/721827/LINQ-Script-A-Universal-Object-Oriented-Database-Q\">LINQ Script: A Universal Object-Oriented Database Query Language</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/646391/A-complex-Mathematics-expression-evaluation-module\">A complex Mathematics expression evaluation module in Visual Basic</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/1088282/VisualBasic-Machine-Learning-Step-The-Q-Learning\">VisualBasic Machine Learning, Step 1: The Q-Learning</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/664153/Modeling-the-Biochemical-System-Using-VB\">Modeling the Biochemical System Using VB</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/820854/Powerful-ShellScript-for-bioinformatics-researcher\">Powerful ShellScript for bioinformatics researchers</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/1095279/Draw-sequence-logo\">Draw sequence logo</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/1076209/Easy-Distribution-Computing-in-VisualBasic\">Easy Distribution Computing in VisualBasic</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/1068466/Simple-HTTP-Server-in-VisualBasic\">Simple HTTP Server in VisualBasic</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/788006/A-powerful-CSV-document-wrapper-library\">A powerful CSV document wrapper library</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/703590/Develop-a-Plugin-extension-for-your-VisualBasic-ap\">Develop a Plugin extension for your VisualBasic application</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/1055849/Levenshtein-Edit-Distance\">Levenshtein Edit Distance [Technical Blog]</a></li>\n<li><a href=\"http://www.codeproject.com/Articles/1055851/Generate-Color-Mappings-on-Circos-plot-for-prokary\">Generate Color Mappings on Circos plot for prokaryote comparative genomics [Technical Blog]</a></li>\n</ol>\n"}],"Post":[{"title":"VB.NET是怎样做到的（搬家版）","date":"2016-06-03T16:00:00.000Z","_content":"\nVB.net能够实现很多C#不能做到的功能，如**When**语句、**Optional**参数、局部**Static**变量、对象实例访问静态方法、**Handles**绑定事件、**On Error**处理异常、**Object**直接后期绑定等等。VB和C#同属.net的语言，编译出来的是同样的CIL，但为什么VB支持很多有趣的特性呢。我们一起来探究一下。\n\n### 局部静态变量\n\nVB支持用**Static**关键字声明局部变量，这样在过程结束的时候可以保持变量的数值：\n```vbnet\nPublic Sub Test1()\n   Static i As Integer\n   i += 1  ' 实现一个过程调用计数器\nEnd Sub\n```\n我们实现了一个简单的过程计数器。每调用一次Test，计数器的数值就增加1。其实还有很多情况我们希望保持变量的数值。而C#的static是不能用在过程内部的。因此要实现过程计数器，我们必须声明一个类级别的变量。这样做明显不如VB好。因为无法防止其他过程修改计数器变量。这就和对象封装一个道理，本来应该是一个方法的局部变量，现在我要被迫把它独立出来，显然是不好的设计。那么VB是怎么生成局部静态变量的呢？将上述代码返汇编，我们可以清楚地看到在VB生成的CIL中，i不是作为局部变量，而是作为类的Field出现的：\n\n```c\n.field private specialname int32 $STATIC$Test1$2001$i\n```\n\n也就是说，i被改名作为一个类的字段，但被冠以specialname。在代码中试图访问$STATIC$Test1$2001$i是不可能的，因为它不是一个有效的标识符。但是在IL中，将这个变量加一的代码却与一般的类字段完全一样，是通过ldfld加载的。我觉得这个方法十分聪明，把静态变量变成生命周期一样的类字段，但是又由编译器来控制访问的权限，让它成为一个局部变量。同时也解释了VB为什么要用两个不同的关键字来声明静态变量——Static和Shared。\n\n由于局部静态变量的实质是类的字段，所以它和真正的局部变量还是有所不同的。比如在多线程条件下，对局部静态变量的访问就和访问字段相同。\n\n### MyClass关键字\n\nVB.net支持一项很有意思的功能——MyClass。大部分人使用MyClass可能仅限于调用本类其他构造函数时。其实MyClass可以产生一些很独特的用法。MyClass永远按类的成员为不可重写的状态进行调用，即当类的方法被重写后，用MyClass仍能得到自身的版本。下面这个例子和VB帮助中所举的例子非常相似\n```vbnet\nPublic Class MyClassBase\n   Protected Overridable Sub Greeting()\n      Console.WriteLine(\"Hello form Base\")\n   End Sub\n\n   Public Sub UseMe()\n      Me.Greeting()\n   End Sub\n\n   Public Sub UseMyClass()\n      MyClass.Greeting()\n   End Sub\nEnd Class\n\nPublic Class MyClassSub\n   Inherits MyClassBase\n\n   Protected Overrides Sub Greeting()\n      Console.WriteLine(\"Hello form Sub\")\n   End Sub\nEnd Class\n```\n\n我们用一段代码来测试：\n```vbnet\nDim o As MyClassBase = New MyClassSub()\n\no.UseMe()\no.UseMyClass()\n```\n结果是UseMe执行了子类的版本，而UseMyClass还是执行了基类本身的版本，尽管这是一个虚拟方法。观其IL，可以看到其简单的实现原理：\n\nMe用的调用指令是callvirt\n\n```c\nIL_0001: callvirt  instance void App1.MyClassBase::Greeting()\n```\n\n而MyClass调用的是call\n```c\nIL_0001:  call     instance void App1.MyClassBase::Greeting()\n```\n\n奇怪的是，如此简单的一个功能，我竟然无法用C#实现，C#怎样也不允许我按非虚函数的方式调用一个虚函数。C++可以用类名::方法名的方式访问自身版本的函数，但C#的类名只能用来访问静态的成员。这真是C#一个奇怪的限制。\n\n### Handles和WithEvents\n\nVB除了可以用C#那样的方法来处理事件响应以外，还有从VB5继承下来的独特的事件处理方式——WithEvents。\n\n我喜欢称这种事件处理方式为静态的事件处理，书写响应事件的方法时就已经决定该方法响应的是哪一个事件，而C#则是在代码中绑定事件的。比如下面这个最简单的例子：\n```vbnet\nPublic Class HandlerClass\n   Public WithEvents MyObj As EventClass\n\n\n   Private Sub MyObj_MyEvent(ByVal sender As Object, ByVal e As System.EventArgs) Handles MyObj.MyEvent\n      MsgBox(\"hello\")\n   End Sub\n\n   Public Sub New()\n      MyObj = New EventClass\n   End Sub\nEnd Class\n```\n代码中用到的EventClass是这样的：\n```vbnet\nPublic Class EventClass\n   Public Event MyEvent As EventHandler\n\n   Protected Overridable Sub OnMyEvent(ByVal e As EventArgs)\n      RaiseEvent MyEvent(Me, e)\n   End Sub\n\n   Public Sub Test()\n      OnMyEvent(New EventArgs)\n   End Sub\nEnd Class\n```\n我们来复习一下，这段代码隐式地给EventClass编写了两个方法——Add_MyEvent(EventHandler)和Remove_MyEvent(EventHandler)，实际上任何使用事件的上下文都是通过调用这两个方法来绑定事件和解除绑定的。C#还允许你书写自己的事件绑定/解除绑定的代码。\n\n那么WithEvents是怎么工作的呢？VB.net的编译器在编译时自动将\n```vbnet\nPublic WithEvents MyObj As EventClass\n```\n翻译成下面这个过程：\n```vbnet\nPrivate _MyObj As EventClass\n\nPublic Property MyObj() As EventClass\n    Get\n        Return _MyObj\n    End Get\n    Set(ByVal Value As EventClass)\n        If Not (Me._MyObj Is Nothing) Then\n            RemoveHandler _MyObj.MyEvent, AddressOf MyObj_MyEvent\n        End If\n        Me._MyObj = Value\n        If Me._MyObj Is Nothing Then Exit Property\n\n        AddHandler _MyObj.MyEvent, AddressOf MyObj_MyEvent\n    End Set\nEnd Property\n```\n\n由此可见，当对WithEvents变量赋值的时候，会自动触发这个属性以绑定事件。我们所用的大部分事件响应都是1对1的，即一个过程响应一个事件，所以这种WithEvents静态方法是非常有用的，它可以显著增强代码可读性，同时也让VB.net中的事件处理非常方便，不像C#那样离开了窗体设计器就必须手工绑定事件。\n\n不过在分析这段IL的时候，我也发现了VB.net在翻译时小小的问题，就是**ldarg.0**出现得过多，这是频繁使用Me或this的表现，所以我们在编码过程中一定要注意，除了使用到Me/this本身引用以外，使用它的成员时不要带上Me/this，比如**Me.MyInt = 1**就改成**MyInt = 1**，这样的小习惯会为你带来很大的性能收益。\n\n### 类型转换运算符\n\n在Visual Basic 2005中将加入一个新的运算符——TryCast，相当于C#的as运算符。我一直希望VB有这样一个运算符。VB目前的类型转换运算符主要有CType和DirectCast。他们的用法几乎一样。我详细比较了一下这两个运算符，得出以下结论：\n\n+ 在转换成引用类型时，两者没有什么区别，都是直接调用castclass指令，除非重载了类型转换运算符CType。DirectCast运算符是不能重载的。\n+ 转换成值类型时，CType会调用VB指定的类型转换函数（如果有的话），比如将String转换为Int32时，就会自动调用**VisualBasic.CompilerServices.IntegerType.FromString**，而将Object转换为Int32则会调用FromObject。其他数值类型转换为Int32时，CType也会调用类型本身的转换方法实施转换。DirectCast运算符则很简单，直接将对象拆箱成所需类型。\n\n所以在用于值类型时，CType没有DirectCast快速但可以支持更多的转换。在C#中，类型转换则为（type)运算符和as运算符。(type)运算符的工作方式与VB的DirectCast很相似，也是直接拆箱或castclass的，但是如果遇到支持的类型转换（如long到int），(type)运算符也会调用相应的转换方法，但不支持从String到int的转换。C#另一个运算符as则更加智能，它只要判断对象的运行实例能否转成目标类型，然后就可以省略castclass指令，直接按已知类型进行操作，而且编译器还可以自动对as进行优化，比如节省一个对象引用等。所以在将Object转换成所需的类型时，as是最佳选择。\n\n由于as有很多优点，Visual Basic 2005将这一特性吸收了过来，用TryCast运算符就可以获得和as一样的效果，而且语法与DirectCast或CType一样。\n\n### 实现接口\n\nVB.net采用的实现接口的语法是VB5发明的Implements，这个实现接口的语法在当今主流语言中独一无二。比如我有两个接口：\n```vbnet\nInterface Interface1\n   Sub Test()\nEnd Interface\n\nInterface Interface2\n   Sub Test()\nEnd Interface\n```\n这两个接口有一个完全一样的成员Test。假设我需要用一个类同时实现两个接口会怎么样呢？先想想看，如果是Java，JScrip.NET这样的语言就只能用一个Test函数实现两个接口的Test成员。假如两个Test只是偶然重名，其内容必须要分别实现怎么办，于是一些解决接口重名的设计出现了……。在VB中，独特的Implements语句可以让你想怎么实现接口就怎么实现，比如下面的类Implementation用两个名字根本不一样的方法实现了两个接口。\n```vbnet\nPublic Class Implementation\n    Implements Interface1, Interface2\n\n    Public Sub Hello() Implements Interface1.Test\n    End Sub\n\n    Private Sub Hi() Implements Interface2.Test\n    End Sub\nEnd Class\n```\n也就是说，VB允许用任意名字的函数实现接口中的成员，而且访问器可以是任意的，比如想用Public还是Private都可以。\n\nC#在处理重名成员上提供了显式实现（explicit implementation）的语法，其实现上述两个接口的语法为\n```c\npublic class Class1 : Interface1, Interface2 {\n    public Class1() {\n    }\n    void Interface1.Test() {\n    }\n    void Interface2.Test() {\n    }\n}\n```\n注意这里，C#只能用接口名.成员名的名字来命名实现方法，而且访问器只能是private，不能公开显式实现的方法。\n\n在考察了IL以后，我发现.NET支持隐式实现和显式实现两种方式。其中隐式实现只要在类里面放一个与接口成员方法名字一样的方法即可——这一种VB不支持。而显式实现则在方法的描述信息里加入：\n```c\n.override TestApp.Interface1::Test\n```\n无论是C#的显式实现还是VB的Implements语句都是这样的原理。也就是说.NET提供了换名实现接口成员的功能，但是只有VB将这个自由让给了用户，而其他语言还是采用了经典的语法。\n\n### 默认属性和属性参数\n\n在原先的VB6里，有一项奇特的功能——默认属性。在VB6中，对象的名称可以直接表示该对象的默认属性。比如TextBox的默认属性是Text，所以下面的代码\n```vbnet\nText1.Text = \"Hello\"\n```\n就可以简化为\n```vbnet\nText1 = \"Hello\"\n```\n这种简化给VB带来了很多麻烦，赋值运算就需要两个关键字——Let和Set，结果属性过程也需要Let和Set两种。而且这种特征在后期绑定的时候仍能工作。到了VB.NET，这项功能被大大限制了，现在只有带参数的属性才可以作为默认属性。如\n```vbnet\nList1.Item(0) = \"Hello\"\n```\n可以简化为\n```vbnet\nList1(0) = \"Hello\"\n```\n这种语法让有默认属性的对象看起来像是一个数组。那么VB怎么判断一个属性是否是默认属性呢？看下列代码\n```vbnet\nPublic Class PropTest \n   Public Property P1(ByVal index As Integer) As String \n      Get \n\n      End Get \n      Set(ByVal Value As String) \n\n      End Set \n   End Property \n\n   Default Public Property P2(ByVal index As Integer) As String \n      Get \n\n      End Get \n      Set(ByVal Value As String) \n\n      End Set \n   End Property \nEnd Class\n```\nP1和P2两个属性基本上完全相同，唯一的不同是P2带有一个Default修饰符。反汇编这个类以后，可以发现两个属性完全相同，没有任何差异。但是PropTest类却被增加了一个自定义元属性**System.Reflection.DefaultMemberAttribute**。这个元属性指定的成员是InvokeMember所使用默认类型，也就是说后期绑定也可以使用默认属性。可是我试验将DefaultMember元属性手工添加到类型上却不能达到让某属性成为默认属性的功能。看来这项功能又是VB的一项“语法甜头”。但是，VB或C#的编译器对别人生成的类的默认属性应该只能通过**DefaultMemberAttribute**来判断，所以我将一个VB类只用**DefaultMemberAttribute**指定一个默认方法，不使用Default，然后将它编译以后给C#用，果然，C#将它识别为一个索引器（indexer）！\n\n既然说到了C#的索引器，我们就顺便来研究一下VB和C#属性方面的不同。刚才的实验结果是VB的默认属性在C#中就是索引器。但是VB仍然可以用属性的语法来访问默认属性，而C#只能用数组的语法访问索引器。更特别的是，VB可以创建不是默认属性，但是带有参数的属性，如上面例子里的P1，而C#则不支持带参数的属性，如果将VB编写的，含有带参数属性的类给C#用，C#会提示“属性不受该语言支持，请用get_XXX和set_XXX的语法访问”。也就是说，带参数的属性是CLR的一项功能，但不符合CLS（通用语言规范），因此就会出现跨语言的障碍。这也更加深了我们对CLS的认识——如果你希望让你的代码跨语言工作，请一定要注意符合CLS。\n\n### 可选参数和按名传递\n\nVB从4.0开始支持“可选参数”这一特性。就是说，函数或子程序的参数有些是可选的，调用的时候可以不输入。其实VB从1.0开始就有一些函数带有可选参数，只不过到了4.0才让用户自己开发这样的过程。在VB4里，可选参数可以不带默认值，而在VB.NET里，如果使用可选参数，则必须带有默认值。如 \n```vbnet\nPublic Sub TestOptional(Optional i As Integer = 1)\n\nEnd Sub\n```\n调用的时候，既可以写成TestOptional(2)，也可以写成TestOptional()，这种情况参数i自动等于1。如果过程有不止一个可选参数，则VB还提供一种简化操作的方法——按名传递参数。比如过程\n```vbnet\nPublic Sub TestOptional(Optional i As Int32 = 1, Optional j As Int32 = 1, Optional k As Int32 = 1) \nEnd Sub \n```\n如果只想指定k，让i和j使用默认值，就可以使用按名传递，如下 \n```vbnet\nTestOptional(k := 2) \n```\n而且这种方式不受参数表顺序的限制 \n```vbnet\nTestOptional(k := 2, i := 3, j := 5) \n```\n这些的确是相当方便的功能，C#就不支持上述两个特性。我们看看它是怎样在IL级别实现的。上述第一个方法在IL中的定义为 \n```c\n.method public instance void TestOptional([opt] int32 i) cil managed\n{\n.param [1] = int32(0x00000001)\n.maxstack 8 \n```\n可见，参数被加上了[opt]修饰符，而且.param指定了参数的默认值。这是只有VB能识别的内容，C#会跳过他们。在调用的时候，VB若发现参数被省略，则自动读取*.param*部分的默认值，并显式传递给过程。这一部分完全由编译器处理，而且没有任何性能损失，和手工传递所有参数是完全一样的。至于按名传递，VB会自动调整参数的顺序，其结果与传统方式的传递也没有任何的不同。这说明我们可以放心地使用这项便利。而且带有可选参数的过程拿到C#中，顶多变成不可选参数，也不会造成什么其他的麻烦。 \n\nPS.很多COM组件都使用了默认参数，而且有些过程的参数列表非常长，在VB里可以轻松地处理它们，而在C#中经常让开发者传参数传到吐血。 \n\n### On Error语句和When语句\n\n本次讨论的是异常处理语句。VB.NET推荐使用**Try...End Try**块来进行结构化的异常处理，但是为了确保兼容性，它也从以前版本的BASIC中借鉴了On Error语句。其实On Error并不能算是VB的优点，因为使用它会破坏程序的结构，让带有异常处理的程序难以看懂和调试。但是我一直很惊叹于VB的工程师是怎样实现它的，因为On Error可以让异常的跳转变得很灵活，不像Try那样受到限制。首先看看Try是怎样实现的：\n```vbnet\nPublic Function F1() As Integer\n   Try\n      Dim n As Integer = 2 \\ n\n   Catch ex As Exception\n      MsgBox(ex.Message)\n   End Try\nEnd Function\n```\n这是最简单的异常处理程序，通过Reflector反汇编（如果用ILDasm，不要选择“展开try-catch”），可以发现整个过程被翻译成19条指令。留意这一句：\n```vbnet\n.try L_0000 to L_0006 catch Exception L_0006 to L_0022\n```\n这就是典型的try块，在catch处直接指定要捕获的异常，然后指定catch区的位置，非常清晰。还要留意这两句：\n```vbnet\nL_0007: call ProjectData.SetProjectError\nL_001b: call ProjectData.ClearProjectError\n```\n可以看出，这两句是在catch块的开头和末尾。深入这两个过程我发现它是在为Err对象记录异常。看来使用Err也是语法甜头，性能苦头，凭空添加了这两句（幸好都不太复杂）。\n\n接下来我编写了一个与此功能类似的函数，用的是On语句处理异常：\n```vbnet\nPublic Function F2() As Integer\n   On Error GoTo CATCHBLOCK\n   Dim n As Integer = 2 \\ n\n   Exit Function\n   \nCATCHBLOCK:\n   MsgBox(Err.Description)\nEnd Function\n```\n这不比上一个过程复杂，但是反汇编以后，它的IL代码竟然有47条指令，刚才才19条啊！最主要的改变是try部分，现在它是这样：\n```c\n.try L_0000 to L_0022 filter L_0022 L_0036 to L_0060\n```\n注意，catch不见了，而出现了filter。我从没在C#生成的IL中见过filter。我查询了Meta Data一节的文档，filter大概能够进行一些过滤，满足一定条件才进入处理异常的块中，本例来说，L_0022指令开始就是过滤器，它是：\n```c\nL_0022: isinst Exception\nL_0027: brfalse.s L_0033\nL_0029: ldloc.s V_4\nL_002b: brfalse.s L_0033\nL_002d: ldloc.3 \nL_002e: brtrue.s L_0033\nL_0030: ldc.i4.1 \nL_0031: br.s L_0034\nL_0033: ldc.i4.0 \nL_0034: endfilter\n```\nendfilter就是异常处理部分代码的开始。而L0030之前的代码是过滤器的判断部分，**V_4**和**V_3**是VB自己加入保存错误代码的变量。在整个反汇编中，我发现设计成处理异常部分的代码在IL里其实也是在try块中，也就是说程序的结构已经不是规整的**try...catch**块，产生异常的语句和处理异常的语句在一起，而真正处理异常的指令是一大堆繁冗拖沓的跳转语句。\n\n下面看看我编写的第三个例子：\n```vbnet\nPublic Function F3() As Integer\n   On Error Resume Next\n   Dim n As Integer = 2 \\ n\nEnd Function\n```\n这个值有2行的过程动用了VB强大的语法杀手——**On Error Resume** Next，它将忽略所有异常，让代码紧接产生异常的语句继续执行下去，猜猜这个功能产生了多少IL指令？答案是**50**条！比普通的**On Error**还要长。其实现我就不多说了，和前面的On语句差不多。不过50这个数字似乎提醒了大家，不要在程序里偷懒使用On Error处理异常，这样产生的代价是不可接受的。\n\n最后一个例子是VB.NET的When语句，它可以实现对Catch部分的过滤：\n```vbnet\nPublic Function F1() As Integer\n   Dim n As Integer = 0\n   Try\n      Dim m As Integer = 2 \\ n\n   Catch ex As Exception When n = 0\n      MsgBox(ex.Message)\n   End Try\nEnd Function\n```\n里面的When语句进行了对变量n的判断，仅当**n = 0**的时候才进入处理部分。\n\n听到“过滤”两个字，我们已经猜出，它是用try...filter来实现的。没错。这里的filter主要是进行ex是否是Exception型，n是否等于零等，当过滤成功，就会转移到异常处理段进行处理。这次VB生成的代码要比On Error语句规则得多，结构相当清晰。\n\n本次我们还借助On Error语句和When语句了解到try filter结构，它是C#不能生成的，因此，我发现它不能被常见的反编译器反编译（因为反编译器的编写者只知道C#，呵呵）。而且用了On Error后程序结构变得异常混乱，这在产生负面作用的时候，是不是能够变相起到保护我们代码的作用呢？\n\n（九）实例访问共享成员\n\n大家都知道静态成员在VB中叫做共享成员，虽然刚接受起来有点别扭，但“共享成员”的确是名副其实的：\n```vbnet\nPublic Class Class1\n   Public Shared i As Integer\n   ' Other none-shared members\nEnd Class\n```\n不但像在C#中那样，可以用Class1.i访问共享成员i，还可以用实例变量来访问:\n```vbnet\nDim c1 As New Class1\nc1.i = 100\n```\n就像i是c1的成员一样！当然只有一个i，任何实例去修改i的值都将导致所有i的值改变（因为其实只有一个）。甚至Me和MyClass也可以访问共享成员。\n```vbnet\nMe.i = 100\nMyClass.i = 100\n```\n这在C#中是不可能做到的，一个纯正的C#程序员看到这些代码一定会觉得匪夷所思。为了揭示它的工作原理，我们可以做下列实验：\n```vbnet\nDim c1 As Class1\nc1.i = 100\n```\n注意，这里的c1为Nothing!，即使是Nothing的变量也可以访问共享成员，而且不会出错。接下来我们实验更极端的情况：\n```vbnet\nDim o As Object = New Class1\no.i = 100\n```\n结果——失败，不能通过后期绑定访问共享成员。现在结果已经很明显，只有在VB明确了解对象类型的情况下，才能使用实例访问共享成员，VB会自动判断类型，然后将所有对共享成员访问的语句改写成\n```vbnet\nClass1.i = 100\n```\n这样的语法。Delphi也支持这一有趣的特征，而且李维在《Inside VCL》中将此说成Delphi.NET相对于.NET的扩展之一。\n>\"结果——失败，不能通过后期绑定访问共享成员\"\n\n那只是编辑器不允许而已，语法结构上并没有错！将Option Strict 设为 off 就不会有错误提示。正在从无知迈向菜鸟...\n","source":"_posts/VBdotNET_howto.md","raw":"---\ntitle: VB.NET是怎样做到的（搬家版）\ntags: [VB.NET,转载搬运]\ndate: 2016.06.04\n---\n\nVB.net能够实现很多C#不能做到的功能，如**When**语句、**Optional**参数、局部**Static**变量、对象实例访问静态方法、**Handles**绑定事件、**On Error**处理异常、**Object**直接后期绑定等等。VB和C#同属.net的语言，编译出来的是同样的CIL，但为什么VB支持很多有趣的特性呢。我们一起来探究一下。\n\n### 局部静态变量\n\nVB支持用**Static**关键字声明局部变量，这样在过程结束的时候可以保持变量的数值：\n```vbnet\nPublic Sub Test1()\n   Static i As Integer\n   i += 1  ' 实现一个过程调用计数器\nEnd Sub\n```\n我们实现了一个简单的过程计数器。每调用一次Test，计数器的数值就增加1。其实还有很多情况我们希望保持变量的数值。而C#的static是不能用在过程内部的。因此要实现过程计数器，我们必须声明一个类级别的变量。这样做明显不如VB好。因为无法防止其他过程修改计数器变量。这就和对象封装一个道理，本来应该是一个方法的局部变量，现在我要被迫把它独立出来，显然是不好的设计。那么VB是怎么生成局部静态变量的呢？将上述代码返汇编，我们可以清楚地看到在VB生成的CIL中，i不是作为局部变量，而是作为类的Field出现的：\n\n```c\n.field private specialname int32 $STATIC$Test1$2001$i\n```\n\n也就是说，i被改名作为一个类的字段，但被冠以specialname。在代码中试图访问$STATIC$Test1$2001$i是不可能的，因为它不是一个有效的标识符。但是在IL中，将这个变量加一的代码却与一般的类字段完全一样，是通过ldfld加载的。我觉得这个方法十分聪明，把静态变量变成生命周期一样的类字段，但是又由编译器来控制访问的权限，让它成为一个局部变量。同时也解释了VB为什么要用两个不同的关键字来声明静态变量——Static和Shared。\n\n由于局部静态变量的实质是类的字段，所以它和真正的局部变量还是有所不同的。比如在多线程条件下，对局部静态变量的访问就和访问字段相同。\n\n### MyClass关键字\n\nVB.net支持一项很有意思的功能——MyClass。大部分人使用MyClass可能仅限于调用本类其他构造函数时。其实MyClass可以产生一些很独特的用法。MyClass永远按类的成员为不可重写的状态进行调用，即当类的方法被重写后，用MyClass仍能得到自身的版本。下面这个例子和VB帮助中所举的例子非常相似\n```vbnet\nPublic Class MyClassBase\n   Protected Overridable Sub Greeting()\n      Console.WriteLine(\"Hello form Base\")\n   End Sub\n\n   Public Sub UseMe()\n      Me.Greeting()\n   End Sub\n\n   Public Sub UseMyClass()\n      MyClass.Greeting()\n   End Sub\nEnd Class\n\nPublic Class MyClassSub\n   Inherits MyClassBase\n\n   Protected Overrides Sub Greeting()\n      Console.WriteLine(\"Hello form Sub\")\n   End Sub\nEnd Class\n```\n\n我们用一段代码来测试：\n```vbnet\nDim o As MyClassBase = New MyClassSub()\n\no.UseMe()\no.UseMyClass()\n```\n结果是UseMe执行了子类的版本，而UseMyClass还是执行了基类本身的版本，尽管这是一个虚拟方法。观其IL，可以看到其简单的实现原理：\n\nMe用的调用指令是callvirt\n\n```c\nIL_0001: callvirt  instance void App1.MyClassBase::Greeting()\n```\n\n而MyClass调用的是call\n```c\nIL_0001:  call     instance void App1.MyClassBase::Greeting()\n```\n\n奇怪的是，如此简单的一个功能，我竟然无法用C#实现，C#怎样也不允许我按非虚函数的方式调用一个虚函数。C++可以用类名::方法名的方式访问自身版本的函数，但C#的类名只能用来访问静态的成员。这真是C#一个奇怪的限制。\n\n### Handles和WithEvents\n\nVB除了可以用C#那样的方法来处理事件响应以外，还有从VB5继承下来的独特的事件处理方式——WithEvents。\n\n我喜欢称这种事件处理方式为静态的事件处理，书写响应事件的方法时就已经决定该方法响应的是哪一个事件，而C#则是在代码中绑定事件的。比如下面这个最简单的例子：\n```vbnet\nPublic Class HandlerClass\n   Public WithEvents MyObj As EventClass\n\n\n   Private Sub MyObj_MyEvent(ByVal sender As Object, ByVal e As System.EventArgs) Handles MyObj.MyEvent\n      MsgBox(\"hello\")\n   End Sub\n\n   Public Sub New()\n      MyObj = New EventClass\n   End Sub\nEnd Class\n```\n代码中用到的EventClass是这样的：\n```vbnet\nPublic Class EventClass\n   Public Event MyEvent As EventHandler\n\n   Protected Overridable Sub OnMyEvent(ByVal e As EventArgs)\n      RaiseEvent MyEvent(Me, e)\n   End Sub\n\n   Public Sub Test()\n      OnMyEvent(New EventArgs)\n   End Sub\nEnd Class\n```\n我们来复习一下，这段代码隐式地给EventClass编写了两个方法——Add_MyEvent(EventHandler)和Remove_MyEvent(EventHandler)，实际上任何使用事件的上下文都是通过调用这两个方法来绑定事件和解除绑定的。C#还允许你书写自己的事件绑定/解除绑定的代码。\n\n那么WithEvents是怎么工作的呢？VB.net的编译器在编译时自动将\n```vbnet\nPublic WithEvents MyObj As EventClass\n```\n翻译成下面这个过程：\n```vbnet\nPrivate _MyObj As EventClass\n\nPublic Property MyObj() As EventClass\n    Get\n        Return _MyObj\n    End Get\n    Set(ByVal Value As EventClass)\n        If Not (Me._MyObj Is Nothing) Then\n            RemoveHandler _MyObj.MyEvent, AddressOf MyObj_MyEvent\n        End If\n        Me._MyObj = Value\n        If Me._MyObj Is Nothing Then Exit Property\n\n        AddHandler _MyObj.MyEvent, AddressOf MyObj_MyEvent\n    End Set\nEnd Property\n```\n\n由此可见，当对WithEvents变量赋值的时候，会自动触发这个属性以绑定事件。我们所用的大部分事件响应都是1对1的，即一个过程响应一个事件，所以这种WithEvents静态方法是非常有用的，它可以显著增强代码可读性，同时也让VB.net中的事件处理非常方便，不像C#那样离开了窗体设计器就必须手工绑定事件。\n\n不过在分析这段IL的时候，我也发现了VB.net在翻译时小小的问题，就是**ldarg.0**出现得过多，这是频繁使用Me或this的表现，所以我们在编码过程中一定要注意，除了使用到Me/this本身引用以外，使用它的成员时不要带上Me/this，比如**Me.MyInt = 1**就改成**MyInt = 1**，这样的小习惯会为你带来很大的性能收益。\n\n### 类型转换运算符\n\n在Visual Basic 2005中将加入一个新的运算符——TryCast，相当于C#的as运算符。我一直希望VB有这样一个运算符。VB目前的类型转换运算符主要有CType和DirectCast。他们的用法几乎一样。我详细比较了一下这两个运算符，得出以下结论：\n\n+ 在转换成引用类型时，两者没有什么区别，都是直接调用castclass指令，除非重载了类型转换运算符CType。DirectCast运算符是不能重载的。\n+ 转换成值类型时，CType会调用VB指定的类型转换函数（如果有的话），比如将String转换为Int32时，就会自动调用**VisualBasic.CompilerServices.IntegerType.FromString**，而将Object转换为Int32则会调用FromObject。其他数值类型转换为Int32时，CType也会调用类型本身的转换方法实施转换。DirectCast运算符则很简单，直接将对象拆箱成所需类型。\n\n所以在用于值类型时，CType没有DirectCast快速但可以支持更多的转换。在C#中，类型转换则为（type)运算符和as运算符。(type)运算符的工作方式与VB的DirectCast很相似，也是直接拆箱或castclass的，但是如果遇到支持的类型转换（如long到int），(type)运算符也会调用相应的转换方法，但不支持从String到int的转换。C#另一个运算符as则更加智能，它只要判断对象的运行实例能否转成目标类型，然后就可以省略castclass指令，直接按已知类型进行操作，而且编译器还可以自动对as进行优化，比如节省一个对象引用等。所以在将Object转换成所需的类型时，as是最佳选择。\n\n由于as有很多优点，Visual Basic 2005将这一特性吸收了过来，用TryCast运算符就可以获得和as一样的效果，而且语法与DirectCast或CType一样。\n\n### 实现接口\n\nVB.net采用的实现接口的语法是VB5发明的Implements，这个实现接口的语法在当今主流语言中独一无二。比如我有两个接口：\n```vbnet\nInterface Interface1\n   Sub Test()\nEnd Interface\n\nInterface Interface2\n   Sub Test()\nEnd Interface\n```\n这两个接口有一个完全一样的成员Test。假设我需要用一个类同时实现两个接口会怎么样呢？先想想看，如果是Java，JScrip.NET这样的语言就只能用一个Test函数实现两个接口的Test成员。假如两个Test只是偶然重名，其内容必须要分别实现怎么办，于是一些解决接口重名的设计出现了……。在VB中，独特的Implements语句可以让你想怎么实现接口就怎么实现，比如下面的类Implementation用两个名字根本不一样的方法实现了两个接口。\n```vbnet\nPublic Class Implementation\n    Implements Interface1, Interface2\n\n    Public Sub Hello() Implements Interface1.Test\n    End Sub\n\n    Private Sub Hi() Implements Interface2.Test\n    End Sub\nEnd Class\n```\n也就是说，VB允许用任意名字的函数实现接口中的成员，而且访问器可以是任意的，比如想用Public还是Private都可以。\n\nC#在处理重名成员上提供了显式实现（explicit implementation）的语法，其实现上述两个接口的语法为\n```c\npublic class Class1 : Interface1, Interface2 {\n    public Class1() {\n    }\n    void Interface1.Test() {\n    }\n    void Interface2.Test() {\n    }\n}\n```\n注意这里，C#只能用接口名.成员名的名字来命名实现方法，而且访问器只能是private，不能公开显式实现的方法。\n\n在考察了IL以后，我发现.NET支持隐式实现和显式实现两种方式。其中隐式实现只要在类里面放一个与接口成员方法名字一样的方法即可——这一种VB不支持。而显式实现则在方法的描述信息里加入：\n```c\n.override TestApp.Interface1::Test\n```\n无论是C#的显式实现还是VB的Implements语句都是这样的原理。也就是说.NET提供了换名实现接口成员的功能，但是只有VB将这个自由让给了用户，而其他语言还是采用了经典的语法。\n\n### 默认属性和属性参数\n\n在原先的VB6里，有一项奇特的功能——默认属性。在VB6中，对象的名称可以直接表示该对象的默认属性。比如TextBox的默认属性是Text，所以下面的代码\n```vbnet\nText1.Text = \"Hello\"\n```\n就可以简化为\n```vbnet\nText1 = \"Hello\"\n```\n这种简化给VB带来了很多麻烦，赋值运算就需要两个关键字——Let和Set，结果属性过程也需要Let和Set两种。而且这种特征在后期绑定的时候仍能工作。到了VB.NET，这项功能被大大限制了，现在只有带参数的属性才可以作为默认属性。如\n```vbnet\nList1.Item(0) = \"Hello\"\n```\n可以简化为\n```vbnet\nList1(0) = \"Hello\"\n```\n这种语法让有默认属性的对象看起来像是一个数组。那么VB怎么判断一个属性是否是默认属性呢？看下列代码\n```vbnet\nPublic Class PropTest \n   Public Property P1(ByVal index As Integer) As String \n      Get \n\n      End Get \n      Set(ByVal Value As String) \n\n      End Set \n   End Property \n\n   Default Public Property P2(ByVal index As Integer) As String \n      Get \n\n      End Get \n      Set(ByVal Value As String) \n\n      End Set \n   End Property \nEnd Class\n```\nP1和P2两个属性基本上完全相同，唯一的不同是P2带有一个Default修饰符。反汇编这个类以后，可以发现两个属性完全相同，没有任何差异。但是PropTest类却被增加了一个自定义元属性**System.Reflection.DefaultMemberAttribute**。这个元属性指定的成员是InvokeMember所使用默认类型，也就是说后期绑定也可以使用默认属性。可是我试验将DefaultMember元属性手工添加到类型上却不能达到让某属性成为默认属性的功能。看来这项功能又是VB的一项“语法甜头”。但是，VB或C#的编译器对别人生成的类的默认属性应该只能通过**DefaultMemberAttribute**来判断，所以我将一个VB类只用**DefaultMemberAttribute**指定一个默认方法，不使用Default，然后将它编译以后给C#用，果然，C#将它识别为一个索引器（indexer）！\n\n既然说到了C#的索引器，我们就顺便来研究一下VB和C#属性方面的不同。刚才的实验结果是VB的默认属性在C#中就是索引器。但是VB仍然可以用属性的语法来访问默认属性，而C#只能用数组的语法访问索引器。更特别的是，VB可以创建不是默认属性，但是带有参数的属性，如上面例子里的P1，而C#则不支持带参数的属性，如果将VB编写的，含有带参数属性的类给C#用，C#会提示“属性不受该语言支持，请用get_XXX和set_XXX的语法访问”。也就是说，带参数的属性是CLR的一项功能，但不符合CLS（通用语言规范），因此就会出现跨语言的障碍。这也更加深了我们对CLS的认识——如果你希望让你的代码跨语言工作，请一定要注意符合CLS。\n\n### 可选参数和按名传递\n\nVB从4.0开始支持“可选参数”这一特性。就是说，函数或子程序的参数有些是可选的，调用的时候可以不输入。其实VB从1.0开始就有一些函数带有可选参数，只不过到了4.0才让用户自己开发这样的过程。在VB4里，可选参数可以不带默认值，而在VB.NET里，如果使用可选参数，则必须带有默认值。如 \n```vbnet\nPublic Sub TestOptional(Optional i As Integer = 1)\n\nEnd Sub\n```\n调用的时候，既可以写成TestOptional(2)，也可以写成TestOptional()，这种情况参数i自动等于1。如果过程有不止一个可选参数，则VB还提供一种简化操作的方法——按名传递参数。比如过程\n```vbnet\nPublic Sub TestOptional(Optional i As Int32 = 1, Optional j As Int32 = 1, Optional k As Int32 = 1) \nEnd Sub \n```\n如果只想指定k，让i和j使用默认值，就可以使用按名传递，如下 \n```vbnet\nTestOptional(k := 2) \n```\n而且这种方式不受参数表顺序的限制 \n```vbnet\nTestOptional(k := 2, i := 3, j := 5) \n```\n这些的确是相当方便的功能，C#就不支持上述两个特性。我们看看它是怎样在IL级别实现的。上述第一个方法在IL中的定义为 \n```c\n.method public instance void TestOptional([opt] int32 i) cil managed\n{\n.param [1] = int32(0x00000001)\n.maxstack 8 \n```\n可见，参数被加上了[opt]修饰符，而且.param指定了参数的默认值。这是只有VB能识别的内容，C#会跳过他们。在调用的时候，VB若发现参数被省略，则自动读取*.param*部分的默认值，并显式传递给过程。这一部分完全由编译器处理，而且没有任何性能损失，和手工传递所有参数是完全一样的。至于按名传递，VB会自动调整参数的顺序，其结果与传统方式的传递也没有任何的不同。这说明我们可以放心地使用这项便利。而且带有可选参数的过程拿到C#中，顶多变成不可选参数，也不会造成什么其他的麻烦。 \n\nPS.很多COM组件都使用了默认参数，而且有些过程的参数列表非常长，在VB里可以轻松地处理它们，而在C#中经常让开发者传参数传到吐血。 \n\n### On Error语句和When语句\n\n本次讨论的是异常处理语句。VB.NET推荐使用**Try...End Try**块来进行结构化的异常处理，但是为了确保兼容性，它也从以前版本的BASIC中借鉴了On Error语句。其实On Error并不能算是VB的优点，因为使用它会破坏程序的结构，让带有异常处理的程序难以看懂和调试。但是我一直很惊叹于VB的工程师是怎样实现它的，因为On Error可以让异常的跳转变得很灵活，不像Try那样受到限制。首先看看Try是怎样实现的：\n```vbnet\nPublic Function F1() As Integer\n   Try\n      Dim n As Integer = 2 \\ n\n   Catch ex As Exception\n      MsgBox(ex.Message)\n   End Try\nEnd Function\n```\n这是最简单的异常处理程序，通过Reflector反汇编（如果用ILDasm，不要选择“展开try-catch”），可以发现整个过程被翻译成19条指令。留意这一句：\n```vbnet\n.try L_0000 to L_0006 catch Exception L_0006 to L_0022\n```\n这就是典型的try块，在catch处直接指定要捕获的异常，然后指定catch区的位置，非常清晰。还要留意这两句：\n```vbnet\nL_0007: call ProjectData.SetProjectError\nL_001b: call ProjectData.ClearProjectError\n```\n可以看出，这两句是在catch块的开头和末尾。深入这两个过程我发现它是在为Err对象记录异常。看来使用Err也是语法甜头，性能苦头，凭空添加了这两句（幸好都不太复杂）。\n\n接下来我编写了一个与此功能类似的函数，用的是On语句处理异常：\n```vbnet\nPublic Function F2() As Integer\n   On Error GoTo CATCHBLOCK\n   Dim n As Integer = 2 \\ n\n   Exit Function\n   \nCATCHBLOCK:\n   MsgBox(Err.Description)\nEnd Function\n```\n这不比上一个过程复杂，但是反汇编以后，它的IL代码竟然有47条指令，刚才才19条啊！最主要的改变是try部分，现在它是这样：\n```c\n.try L_0000 to L_0022 filter L_0022 L_0036 to L_0060\n```\n注意，catch不见了，而出现了filter。我从没在C#生成的IL中见过filter。我查询了Meta Data一节的文档，filter大概能够进行一些过滤，满足一定条件才进入处理异常的块中，本例来说，L_0022指令开始就是过滤器，它是：\n```c\nL_0022: isinst Exception\nL_0027: brfalse.s L_0033\nL_0029: ldloc.s V_4\nL_002b: brfalse.s L_0033\nL_002d: ldloc.3 \nL_002e: brtrue.s L_0033\nL_0030: ldc.i4.1 \nL_0031: br.s L_0034\nL_0033: ldc.i4.0 \nL_0034: endfilter\n```\nendfilter就是异常处理部分代码的开始。而L0030之前的代码是过滤器的判断部分，**V_4**和**V_3**是VB自己加入保存错误代码的变量。在整个反汇编中，我发现设计成处理异常部分的代码在IL里其实也是在try块中，也就是说程序的结构已经不是规整的**try...catch**块，产生异常的语句和处理异常的语句在一起，而真正处理异常的指令是一大堆繁冗拖沓的跳转语句。\n\n下面看看我编写的第三个例子：\n```vbnet\nPublic Function F3() As Integer\n   On Error Resume Next\n   Dim n As Integer = 2 \\ n\nEnd Function\n```\n这个值有2行的过程动用了VB强大的语法杀手——**On Error Resume** Next，它将忽略所有异常，让代码紧接产生异常的语句继续执行下去，猜猜这个功能产生了多少IL指令？答案是**50**条！比普通的**On Error**还要长。其实现我就不多说了，和前面的On语句差不多。不过50这个数字似乎提醒了大家，不要在程序里偷懒使用On Error处理异常，这样产生的代价是不可接受的。\n\n最后一个例子是VB.NET的When语句，它可以实现对Catch部分的过滤：\n```vbnet\nPublic Function F1() As Integer\n   Dim n As Integer = 0\n   Try\n      Dim m As Integer = 2 \\ n\n   Catch ex As Exception When n = 0\n      MsgBox(ex.Message)\n   End Try\nEnd Function\n```\n里面的When语句进行了对变量n的判断，仅当**n = 0**的时候才进入处理部分。\n\n听到“过滤”两个字，我们已经猜出，它是用try...filter来实现的。没错。这里的filter主要是进行ex是否是Exception型，n是否等于零等，当过滤成功，就会转移到异常处理段进行处理。这次VB生成的代码要比On Error语句规则得多，结构相当清晰。\n\n本次我们还借助On Error语句和When语句了解到try filter结构，它是C#不能生成的，因此，我发现它不能被常见的反编译器反编译（因为反编译器的编写者只知道C#，呵呵）。而且用了On Error后程序结构变得异常混乱，这在产生负面作用的时候，是不是能够变相起到保护我们代码的作用呢？\n\n（九）实例访问共享成员\n\n大家都知道静态成员在VB中叫做共享成员，虽然刚接受起来有点别扭，但“共享成员”的确是名副其实的：\n```vbnet\nPublic Class Class1\n   Public Shared i As Integer\n   ' Other none-shared members\nEnd Class\n```\n不但像在C#中那样，可以用Class1.i访问共享成员i，还可以用实例变量来访问:\n```vbnet\nDim c1 As New Class1\nc1.i = 100\n```\n就像i是c1的成员一样！当然只有一个i，任何实例去修改i的值都将导致所有i的值改变（因为其实只有一个）。甚至Me和MyClass也可以访问共享成员。\n```vbnet\nMe.i = 100\nMyClass.i = 100\n```\n这在C#中是不可能做到的，一个纯正的C#程序员看到这些代码一定会觉得匪夷所思。为了揭示它的工作原理，我们可以做下列实验：\n```vbnet\nDim c1 As Class1\nc1.i = 100\n```\n注意，这里的c1为Nothing!，即使是Nothing的变量也可以访问共享成员，而且不会出错。接下来我们实验更极端的情况：\n```vbnet\nDim o As Object = New Class1\no.i = 100\n```\n结果——失败，不能通过后期绑定访问共享成员。现在结果已经很明显，只有在VB明确了解对象类型的情况下，才能使用实例访问共享成员，VB会自动判断类型，然后将所有对共享成员访问的语句改写成\n```vbnet\nClass1.i = 100\n```\n这样的语法。Delphi也支持这一有趣的特征，而且李维在《Inside VCL》中将此说成Delphi.NET相对于.NET的扩展之一。\n>\"结果——失败，不能通过后期绑定访问共享成员\"\n\n那只是编辑器不允许而已，语法结构上并没有错！将Option Strict 设为 off 就不会有错误提示。正在从无知迈向菜鸟...\n","slug":"VBdotNET_howto","published":1,"updated":"2016-06-03T19:27:02.644Z","_id":"cip02xkqj00016sv4sj3qkkgk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>VB.net能够实现很多C#不能做到的功能，如<strong>When</strong>语句、<strong>Optional</strong>参数、局部<strong>Static</strong>变量、对象实例访问静态方法、<strong>Handles</strong>绑定事件、<strong>On Error</strong>处理异常、<strong>Object</strong>直接后期绑定等等。VB和C#同属.net的语言，编译出来的是同样的CIL，但为什么VB支持很多有趣的特性呢。我们一起来探究一下。</p>\n<h3 id=\"局部静态变量\"><a href=\"#局部静态变量\" class=\"headerlink\" title=\"局部静态变量\"></a>局部静态变量</h3><p>VB支持用<strong>Static</strong>关键字声明局部变量，这样在过程结束的时候可以保持变量的数值：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Sub</span> Test1()</span><br><span class=\"line\">   <span class=\"keyword\">Static</span> i <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span></span><br><span class=\"line\">   i += <span class=\"number\">1</span>  <span class=\"comment\">' 实现一个过程调用计数器</span></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br></pre></td></tr></table></figure></p>\n<p>我们实现了一个简单的过程计数器。每调用一次Test，计数器的数值就增加1。其实还有很多情况我们希望保持变量的数值。而C#的static是不能用在过程内部的。因此要实现过程计数器，我们必须声明一个类级别的变量。这样做明显不如VB好。因为无法防止其他过程修改计数器变量。这就和对象封装一个道理，本来应该是一个方法的局部变量，现在我要被迫把它独立出来，显然是不好的设计。那么VB是怎么生成局部静态变量的呢？将上述代码返汇编，我们可以清楚地看到在VB生成的CIL中，i不是作为局部变量，而是作为类的Field出现的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.field <span class=\"keyword\">private</span> specialname int32 $STATIC$Test1$<span class=\"number\">2001</span>$i</span><br></pre></td></tr></table></figure>\n<p>也就是说，i被改名作为一个类的字段，但被冠以specialname。在代码中试图访问$STATIC$Test1$2001$i是不可能的，因为它不是一个有效的标识符。但是在IL中，将这个变量加一的代码却与一般的类字段完全一样，是通过ldfld加载的。我觉得这个方法十分聪明，把静态变量变成生命周期一样的类字段，但是又由编译器来控制访问的权限，让它成为一个局部变量。同时也解释了VB为什么要用两个不同的关键字来声明静态变量——Static和Shared。</p>\n<p>由于局部静态变量的实质是类的字段，所以它和真正的局部变量还是有所不同的。比如在多线程条件下，对局部静态变量的访问就和访问字段相同。</p>\n<h3 id=\"MyClass关键字\"><a href=\"#MyClass关键字\" class=\"headerlink\" title=\"MyClass关键字\"></a>MyClass关键字</h3><p>VB.net支持一项很有意思的功能——MyClass。大部分人使用MyClass可能仅限于调用本类其他构造函数时。其实MyClass可以产生一些很独特的用法。MyClass永远按类的成员为不可重写的状态进行调用，即当类的方法被重写后，用MyClass仍能得到自身的版本。下面这个例子和VB帮助中所举的例子非常相似<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Class</span> MyClassBase</span><br><span class=\"line\">   <span class=\"keyword\">Protected</span> <span class=\"keyword\">Overridable</span> <span class=\"keyword\">Sub</span> Greeting()</span><br><span class=\"line\">      Console.WriteLine(<span class=\"string\">\"Hello form Base\"</span>)</span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">Public</span> <span class=\"keyword\">Sub</span> UseMe()</span><br><span class=\"line\">      <span class=\"keyword\">Me</span>.Greeting()</span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">Public</span> <span class=\"keyword\">Sub</span> UseMyClass()</span><br><span class=\"line\">      <span class=\"keyword\">MyClass</span>.Greeting()</span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Class</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Class</span> MyClassSub</span><br><span class=\"line\">   <span class=\"keyword\">Inherits</span> MyClassBase</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">Protected</span> <span class=\"keyword\">Overrides</span> <span class=\"keyword\">Sub</span> Greeting()</span><br><span class=\"line\">      Console.WriteLine(<span class=\"string\">\"Hello form Sub\"</span>)</span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Class</span></span><br></pre></td></tr></table></figure></p>\n<p>我们用一段代码来测试：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Dim</span> o <span class=\"keyword\">As</span> MyClassBase = <span class=\"keyword\">New</span> MyClassSub()</span><br><span class=\"line\"></span><br><span class=\"line\">o.UseMe()</span><br><span class=\"line\">o.UseMyClass()</span><br></pre></td></tr></table></figure></p>\n<p>结果是UseMe执行了子类的版本，而UseMyClass还是执行了基类本身的版本，尽管这是一个虚拟方法。观其IL，可以看到其简单的实现原理：</p>\n<p>Me用的调用指令是callvirt</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IL_0001: callvirt  instance <span class=\"keyword\">void</span> App1.MyClassBase::Greeting()</span><br></pre></td></tr></table></figure>\n<p>而MyClass调用的是call<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IL_0001:  call     instance <span class=\"keyword\">void</span> App1.MyClassBase::Greeting()</span><br></pre></td></tr></table></figure></p>\n<p>奇怪的是，如此简单的一个功能，我竟然无法用C#实现，C#怎样也不允许我按非虚函数的方式调用一个虚函数。C++可以用类名::方法名的方式访问自身版本的函数，但C#的类名只能用来访问静态的成员。这真是C#一个奇怪的限制。</p>\n<h3 id=\"Handles和WithEvents\"><a href=\"#Handles和WithEvents\" class=\"headerlink\" title=\"Handles和WithEvents\"></a>Handles和WithEvents</h3><p>VB除了可以用C#那样的方法来处理事件响应以外，还有从VB5继承下来的独特的事件处理方式——WithEvents。</p>\n<p>我喜欢称这种事件处理方式为静态的事件处理，书写响应事件的方法时就已经决定该方法响应的是哪一个事件，而C#则是在代码中绑定事件的。比如下面这个最简单的例子：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Class</span> HandlerClass</span><br><span class=\"line\">   <span class=\"keyword\">Public</span> <span class=\"keyword\">WithEvents</span> MyObj <span class=\"keyword\">As</span> EventClass</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">Private</span> <span class=\"keyword\">Sub</span> MyObj_MyEvent(<span class=\"keyword\">ByVal</span> sender <span class=\"keyword\">As</span> <span class=\"built_in\">Object</span>, <span class=\"keyword\">ByVal</span> e <span class=\"keyword\">As</span> System.EventArgs) <span class=\"keyword\">Handles</span> MyObj.MyEvent</span><br><span class=\"line\">      MsgBox(<span class=\"string\">\"hello\"</span>)</span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">Public</span> <span class=\"keyword\">Sub</span> <span class=\"keyword\">New</span>()</span><br><span class=\"line\">      MyObj = <span class=\"keyword\">New</span> EventClass</span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Class</span></span><br></pre></td></tr></table></figure></p>\n<p>代码中用到的EventClass是这样的：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Class</span> EventClass</span><br><span class=\"line\">   <span class=\"keyword\">Public</span> <span class=\"keyword\">Event</span> MyEvent <span class=\"keyword\">As</span> EventHandler</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">Protected</span> <span class=\"keyword\">Overridable</span> <span class=\"keyword\">Sub</span> OnMyEvent(<span class=\"keyword\">ByVal</span> e <span class=\"keyword\">As</span> EventArgs)</span><br><span class=\"line\">      <span class=\"keyword\">RaiseEvent</span> MyEvent(<span class=\"keyword\">Me</span>, e)</span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">Public</span> <span class=\"keyword\">Sub</span> Test()</span><br><span class=\"line\">      OnMyEvent(<span class=\"keyword\">New</span> EventArgs)</span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Class</span></span><br></pre></td></tr></table></figure></p>\n<p>我们来复习一下，这段代码隐式地给EventClass编写了两个方法——Add_MyEvent(EventHandler)和Remove_MyEvent(EventHandler)，实际上任何使用事件的上下文都是通过调用这两个方法来绑定事件和解除绑定的。C#还允许你书写自己的事件绑定/解除绑定的代码。</p>\n<p>那么WithEvents是怎么工作的呢？VB.net的编译器在编译时自动将<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">WithEvents</span> MyObj <span class=\"keyword\">As</span> EventClass</span><br></pre></td></tr></table></figure></p>\n<p>翻译成下面这个过程：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Private</span> _MyObj <span class=\"keyword\">As</span> EventClass</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Property</span> MyObj() <span class=\"keyword\">As</span> EventClass</span><br><span class=\"line\">    <span class=\"keyword\">Get</span></span><br><span class=\"line\">        <span class=\"keyword\">Return</span> _MyObj</span><br><span class=\"line\">    <span class=\"keyword\">End</span> <span class=\"keyword\">Get</span></span><br><span class=\"line\">    <span class=\"keyword\">Set</span>(<span class=\"keyword\">ByVal</span> Value <span class=\"keyword\">As</span> EventClass)</span><br><span class=\"line\">        <span class=\"keyword\">If</span> <span class=\"keyword\">Not</span> (<span class=\"keyword\">Me</span>._MyObj <span class=\"keyword\">Is</span> <span class=\"literal\">Nothing</span>) <span class=\"keyword\">Then</span></span><br><span class=\"line\">            <span class=\"keyword\">RemoveHandler</span> _MyObj.MyEvent, <span class=\"keyword\">AddressOf</span> MyObj_MyEvent</span><br><span class=\"line\">        <span class=\"keyword\">End</span> <span class=\"keyword\">If</span></span><br><span class=\"line\">        <span class=\"keyword\">Me</span>._MyObj = Value</span><br><span class=\"line\">        <span class=\"keyword\">If</span> <span class=\"keyword\">Me</span>._MyObj <span class=\"keyword\">Is</span> <span class=\"literal\">Nothing</span> <span class=\"keyword\">Then</span> <span class=\"keyword\">Exit</span> <span class=\"keyword\">Property</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">AddHandler</span> _MyObj.MyEvent, <span class=\"keyword\">AddressOf</span> MyObj_MyEvent</span><br><span class=\"line\">    <span class=\"keyword\">End</span> <span class=\"keyword\">Set</span></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Property</span></span><br></pre></td></tr></table></figure></p>\n<p>由此可见，当对WithEvents变量赋值的时候，会自动触发这个属性以绑定事件。我们所用的大部分事件响应都是1对1的，即一个过程响应一个事件，所以这种WithEvents静态方法是非常有用的，它可以显著增强代码可读性，同时也让VB.net中的事件处理非常方便，不像C#那样离开了窗体设计器就必须手工绑定事件。</p>\n<p>不过在分析这段IL的时候，我也发现了VB.net在翻译时小小的问题，就是<strong>ldarg.0</strong>出现得过多，这是频繁使用Me或this的表现，所以我们在编码过程中一定要注意，除了使用到Me/this本身引用以外，使用它的成员时不要带上Me/this，比如<strong>Me.MyInt = 1</strong>就改成<strong>MyInt = 1</strong>，这样的小习惯会为你带来很大的性能收益。</p>\n<h3 id=\"类型转换运算符\"><a href=\"#类型转换运算符\" class=\"headerlink\" title=\"类型转换运算符\"></a>类型转换运算符</h3><p>在Visual Basic 2005中将加入一个新的运算符——TryCast，相当于C#的as运算符。我一直希望VB有这样一个运算符。VB目前的类型转换运算符主要有CType和DirectCast。他们的用法几乎一样。我详细比较了一下这两个运算符，得出以下结论：</p>\n<ul>\n<li>在转换成引用类型时，两者没有什么区别，都是直接调用castclass指令，除非重载了类型转换运算符CType。DirectCast运算符是不能重载的。</li>\n<li>转换成值类型时，CType会调用VB指定的类型转换函数（如果有的话），比如将String转换为Int32时，就会自动调用<strong>VisualBasic.CompilerServices.IntegerType.FromString</strong>，而将Object转换为Int32则会调用FromObject。其他数值类型转换为Int32时，CType也会调用类型本身的转换方法实施转换。DirectCast运算符则很简单，直接将对象拆箱成所需类型。</li>\n</ul>\n<p>所以在用于值类型时，CType没有DirectCast快速但可以支持更多的转换。在C#中，类型转换则为（type)运算符和as运算符。(type)运算符的工作方式与VB的DirectCast很相似，也是直接拆箱或castclass的，但是如果遇到支持的类型转换（如long到int），(type)运算符也会调用相应的转换方法，但不支持从String到int的转换。C#另一个运算符as则更加智能，它只要判断对象的运行实例能否转成目标类型，然后就可以省略castclass指令，直接按已知类型进行操作，而且编译器还可以自动对as进行优化，比如节省一个对象引用等。所以在将Object转换成所需的类型时，as是最佳选择。</p>\n<p>由于as有很多优点，Visual Basic 2005将这一特性吸收了过来，用TryCast运算符就可以获得和as一样的效果，而且语法与DirectCast或CType一样。</p>\n<h3 id=\"实现接口\"><a href=\"#实现接口\" class=\"headerlink\" title=\"实现接口\"></a>实现接口</h3><p>VB.net采用的实现接口的语法是VB5发明的Implements，这个实现接口的语法在当今主流语言中独一无二。比如我有两个接口：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Interface</span> Interface1</span><br><span class=\"line\">   <span class=\"keyword\">Sub</span> Test()</span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Interface</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Interface</span> Interface2</span><br><span class=\"line\">   <span class=\"keyword\">Sub</span> Test()</span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Interface</span></span><br></pre></td></tr></table></figure></p>\n<p>这两个接口有一个完全一样的成员Test。假设我需要用一个类同时实现两个接口会怎么样呢？先想想看，如果是Java，JScrip.NET这样的语言就只能用一个Test函数实现两个接口的Test成员。假如两个Test只是偶然重名，其内容必须要分别实现怎么办，于是一些解决接口重名的设计出现了……。在VB中，独特的Implements语句可以让你想怎么实现接口就怎么实现，比如下面的类Implementation用两个名字根本不一样的方法实现了两个接口。<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Class</span> Implementation</span><br><span class=\"line\">    <span class=\"keyword\">Implements</span> Interface1, Interface2</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">Public</span> <span class=\"keyword\">Sub</span> Hello() <span class=\"keyword\">Implements</span> Interface1.Test</span><br><span class=\"line\">    <span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">Private</span> <span class=\"keyword\">Sub</span> Hi() <span class=\"keyword\">Implements</span> Interface2.Test</span><br><span class=\"line\">    <span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Class</span></span><br></pre></td></tr></table></figure></p>\n<p>也就是说，VB允许用任意名字的函数实现接口中的成员，而且访问器可以是任意的，比如想用Public还是Private都可以。</p>\n<p>C#在处理重名成员上提供了显式实现（explicit implementation）的语法，其实现上述两个接口的语法为<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> Class1 : Interface1, Interface2 &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Class1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> Interface1.Test() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> Interface2.Test() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意这里，C#只能用接口名.成员名的名字来命名实现方法，而且访问器只能是private，不能公开显式实现的方法。</p>\n<p>在考察了IL以后，我发现.NET支持隐式实现和显式实现两种方式。其中隐式实现只要在类里面放一个与接口成员方法名字一样的方法即可——这一种VB不支持。而显式实现则在方法的描述信息里加入：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.override TestApp.Interface1::Test</span><br></pre></td></tr></table></figure></p>\n<p>无论是C#的显式实现还是VB的Implements语句都是这样的原理。也就是说.NET提供了换名实现接口成员的功能，但是只有VB将这个自由让给了用户，而其他语言还是采用了经典的语法。</p>\n<h3 id=\"默认属性和属性参数\"><a href=\"#默认属性和属性参数\" class=\"headerlink\" title=\"默认属性和属性参数\"></a>默认属性和属性参数</h3><p>在原先的VB6里，有一项奇特的功能——默认属性。在VB6中，对象的名称可以直接表示该对象的默认属性。比如TextBox的默认属性是Text，所以下面的代码<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Text1.<span class=\"keyword\">Text</span> = <span class=\"string\">\"Hello\"</span></span><br></pre></td></tr></table></figure></p>\n<p>就可以简化为<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Text1 = <span class=\"string\">\"Hello\"</span></span><br></pre></td></tr></table></figure></p>\n<p>这种简化给VB带来了很多麻烦，赋值运算就需要两个关键字——Let和Set，结果属性过程也需要Let和Set两种。而且这种特征在后期绑定的时候仍能工作。到了VB.NET，这项功能被大大限制了，现在只有带参数的属性才可以作为默认属性。如<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List1.Item(<span class=\"number\">0</span>) = <span class=\"string\">\"Hello\"</span></span><br></pre></td></tr></table></figure></p>\n<p>可以简化为<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List1(<span class=\"number\">0</span>) = <span class=\"string\">\"Hello\"</span></span><br></pre></td></tr></table></figure></p>\n<p>这种语法让有默认属性的对象看起来像是一个数组。那么VB怎么判断一个属性是否是默认属性呢？看下列代码<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Class</span> PropTest </span><br><span class=\"line\">   <span class=\"keyword\">Public</span> <span class=\"keyword\">Property</span> P1(<span class=\"keyword\">ByVal</span> index <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span>) <span class=\"keyword\">As</span> <span class=\"built_in\">String</span> </span><br><span class=\"line\">      <span class=\"keyword\">Get</span> </span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">End</span> <span class=\"keyword\">Get</span> </span><br><span class=\"line\">      <span class=\"keyword\">Set</span>(<span class=\"keyword\">ByVal</span> Value <span class=\"keyword\">As</span> <span class=\"built_in\">String</span>) </span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">End</span> <span class=\"keyword\">Set</span> </span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Property</span> </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">Default</span> <span class=\"keyword\">Public</span> <span class=\"keyword\">Property</span> P2(<span class=\"keyword\">ByVal</span> index <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span>) <span class=\"keyword\">As</span> <span class=\"built_in\">String</span> </span><br><span class=\"line\">      <span class=\"keyword\">Get</span> </span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">End</span> <span class=\"keyword\">Get</span> </span><br><span class=\"line\">      <span class=\"keyword\">Set</span>(<span class=\"keyword\">ByVal</span> Value <span class=\"keyword\">As</span> <span class=\"built_in\">String</span>) </span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">End</span> <span class=\"keyword\">Set</span> </span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Property</span> </span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Class</span></span><br></pre></td></tr></table></figure></p>\n<p>P1和P2两个属性基本上完全相同，唯一的不同是P2带有一个Default修饰符。反汇编这个类以后，可以发现两个属性完全相同，没有任何差异。但是PropTest类却被增加了一个自定义元属性<strong>System.Reflection.DefaultMemberAttribute</strong>。这个元属性指定的成员是InvokeMember所使用默认类型，也就是说后期绑定也可以使用默认属性。可是我试验将DefaultMember元属性手工添加到类型上却不能达到让某属性成为默认属性的功能。看来这项功能又是VB的一项“语法甜头”。但是，VB或C#的编译器对别人生成的类的默认属性应该只能通过<strong>DefaultMemberAttribute</strong>来判断，所以我将一个VB类只用<strong>DefaultMemberAttribute</strong>指定一个默认方法，不使用Default，然后将它编译以后给C#用，果然，C#将它识别为一个索引器（indexer）！</p>\n<p>既然说到了C#的索引器，我们就顺便来研究一下VB和C#属性方面的不同。刚才的实验结果是VB的默认属性在C#中就是索引器。但是VB仍然可以用属性的语法来访问默认属性，而C#只能用数组的语法访问索引器。更特别的是，VB可以创建不是默认属性，但是带有参数的属性，如上面例子里的P1，而C#则不支持带参数的属性，如果将VB编写的，含有带参数属性的类给C#用，C#会提示“属性不受该语言支持，请用get_XXX和set_XXX的语法访问”。也就是说，带参数的属性是CLR的一项功能，但不符合CLS（通用语言规范），因此就会出现跨语言的障碍。这也更加深了我们对CLS的认识——如果你希望让你的代码跨语言工作，请一定要注意符合CLS。</p>\n<h3 id=\"可选参数和按名传递\"><a href=\"#可选参数和按名传递\" class=\"headerlink\" title=\"可选参数和按名传递\"></a>可选参数和按名传递</h3><p>VB从4.0开始支持“可选参数”这一特性。就是说，函数或子程序的参数有些是可选的，调用的时候可以不输入。其实VB从1.0开始就有一些函数带有可选参数，只不过到了4.0才让用户自己开发这样的过程。在VB4里，可选参数可以不带默认值，而在VB.NET里，如果使用可选参数，则必须带有默认值。如<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Sub</span> TestOptional(<span class=\"keyword\">Optional</span> i <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span> = <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br></pre></td></tr></table></figure></p>\n<p>调用的时候，既可以写成TestOptional(2)，也可以写成TestOptional()，这种情况参数i自动等于1。如果过程有不止一个可选参数，则VB还提供一种简化操作的方法——按名传递参数。比如过程<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Sub</span> TestOptional(<span class=\"keyword\">Optional</span> i <span class=\"keyword\">As</span> Int32 = <span class=\"number\">1</span>, <span class=\"keyword\">Optional</span> j <span class=\"keyword\">As</span> Int32 = <span class=\"number\">1</span>, <span class=\"keyword\">Optional</span> k <span class=\"keyword\">As</span> Int32 = <span class=\"number\">1</span>) </span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br></pre></td></tr></table></figure></p>\n<p>如果只想指定k，让i和j使用默认值，就可以使用按名传递，如下<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestOptional(k := <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure></p>\n<p>而且这种方式不受参数表顺序的限制<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestOptional(k := <span class=\"number\">2</span>, i := <span class=\"number\">3</span>, j := <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure></p>\n<p>这些的确是相当方便的功能，C#就不支持上述两个特性。我们看看它是怎样在IL级别实现的。上述第一个方法在IL中的定义为<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.<span class=\"function\">method <span class=\"keyword\">public</span> instance <span class=\"keyword\">void</span> <span class=\"title\">TestOptional</span><span class=\"params\">([opt] int32 i)</span> cil managed</span><br><span class=\"line\"></span>&#123;</span><br><span class=\"line\">.param [<span class=\"number\">1</span>] = int32(<span class=\"number\">0x00000001</span>)</span><br><span class=\"line\">.maxstack <span class=\"number\">8</span></span><br></pre></td></tr></table></figure></p>\n<p>可见，参数被加上了[opt]修饰符，而且.param指定了参数的默认值。这是只有VB能识别的内容，C#会跳过他们。在调用的时候，VB若发现参数被省略，则自动读取<em>.param</em>部分的默认值，并显式传递给过程。这一部分完全由编译器处理，而且没有任何性能损失，和手工传递所有参数是完全一样的。至于按名传递，VB会自动调整参数的顺序，其结果与传统方式的传递也没有任何的不同。这说明我们可以放心地使用这项便利。而且带有可选参数的过程拿到C#中，顶多变成不可选参数，也不会造成什么其他的麻烦。 </p>\n<p>PS.很多COM组件都使用了默认参数，而且有些过程的参数列表非常长，在VB里可以轻松地处理它们，而在C#中经常让开发者传参数传到吐血。 </p>\n<h3 id=\"On-Error语句和When语句\"><a href=\"#On-Error语句和When语句\" class=\"headerlink\" title=\"On Error语句和When语句\"></a>On Error语句和When语句</h3><p>本次讨论的是异常处理语句。VB.NET推荐使用<strong>Try…End Try</strong>块来进行结构化的异常处理，但是为了确保兼容性，它也从以前版本的BASIC中借鉴了On Error语句。其实On Error并不能算是VB的优点，因为使用它会破坏程序的结构，让带有异常处理的程序难以看懂和调试。但是我一直很惊叹于VB的工程师是怎样实现它的，因为On Error可以让异常的跳转变得很灵活，不像Try那样受到限制。首先看看Try是怎样实现的：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Function</span> F1() <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span></span><br><span class=\"line\">   <span class=\"keyword\">Try</span></span><br><span class=\"line\">      <span class=\"keyword\">Dim</span> n <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span> = <span class=\"number\">2</span> \\ n</span><br><span class=\"line\">   <span class=\"keyword\">Catch</span> ex <span class=\"keyword\">As</span> Exception</span><br><span class=\"line\">      MsgBox(ex.Message)</span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Try</span></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Function</span></span><br></pre></td></tr></table></figure></p>\n<p>这是最简单的异常处理程序，通过Reflector反汇编（如果用ILDasm，不要选择“展开try-catch”），可以发现整个过程被翻译成19条指令。留意这一句：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.<span class=\"keyword\">try</span> L_0000 <span class=\"keyword\">to</span> L_0006 <span class=\"keyword\">catch</span> Exception L_0006 <span class=\"keyword\">to</span> L_0022</span><br></pre></td></tr></table></figure></p>\n<p>这就是典型的try块，在catch处直接指定要捕获的异常，然后指定catch区的位置，非常清晰。还要留意这两句：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L_0007: <span class=\"keyword\">call</span> ProjectData.SetProjectError</span><br><span class=\"line\">L_001b: <span class=\"keyword\">call</span> ProjectData.ClearProjectError</span><br></pre></td></tr></table></figure></p>\n<p>可以看出，这两句是在catch块的开头和末尾。深入这两个过程我发现它是在为Err对象记录异常。看来使用Err也是语法甜头，性能苦头，凭空添加了这两句（幸好都不太复杂）。</p>\n<p>接下来我编写了一个与此功能类似的函数，用的是On语句处理异常：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Function</span> F2() <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span></span><br><span class=\"line\">   <span class=\"keyword\">On</span> <span class=\"keyword\">Error</span> <span class=\"keyword\">GoTo</span> CATCHBLOCK</span><br><span class=\"line\">   <span class=\"keyword\">Dim</span> n <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span> = <span class=\"number\">2</span> \\ n</span><br><span class=\"line\">   <span class=\"keyword\">Exit</span> <span class=\"keyword\">Function</span></span><br><span class=\"line\">   </span><br><span class=\"line\">CATCHBLOCK:</span><br><span class=\"line\">   MsgBox(Err.Description)</span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Function</span></span><br></pre></td></tr></table></figure></p>\n<p>这不比上一个过程复杂，但是反汇编以后，它的IL代码竟然有47条指令，刚才才19条啊！最主要的改变是try部分，现在它是这样：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.<span class=\"keyword\">try</span> L_0000 to L_0022 filter L_0022 L_0036 to L_0060</span><br></pre></td></tr></table></figure></p>\n<p>注意，catch不见了，而出现了filter。我从没在C#生成的IL中见过filter。我查询了Meta Data一节的文档，filter大概能够进行一些过滤，满足一定条件才进入处理异常的块中，本例来说，L_0022指令开始就是过滤器，它是：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L_0022: isinst Exception</span><br><span class=\"line\">L_0027: brfalse.s L_0033</span><br><span class=\"line\">L_0029: ldloc.s V_4</span><br><span class=\"line\">L_002b: brfalse.s L_0033</span><br><span class=\"line\">L_002d: ldloc<span class=\"number\">.3</span> </span><br><span class=\"line\">L_002e: brtrue.s L_0033</span><br><span class=\"line\">L_0030: ldc.i4<span class=\"number\">.1</span> </span><br><span class=\"line\">L_0031: br.s L_0034</span><br><span class=\"line\">L_0033: ldc.i4<span class=\"number\">.0</span> </span><br><span class=\"line\">L_0034: endfilter</span><br></pre></td></tr></table></figure></p>\n<p>endfilter就是异常处理部分代码的开始。而L0030之前的代码是过滤器的判断部分，<strong>V_4</strong>和<strong>V_3</strong>是VB自己加入保存错误代码的变量。在整个反汇编中，我发现设计成处理异常部分的代码在IL里其实也是在try块中，也就是说程序的结构已经不是规整的<strong>try…catch</strong>块，产生异常的语句和处理异常的语句在一起，而真正处理异常的指令是一大堆繁冗拖沓的跳转语句。</p>\n<p>下面看看我编写的第三个例子：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Function</span> F3() <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span></span><br><span class=\"line\">   <span class=\"keyword\">On</span> <span class=\"keyword\">Error</span> <span class=\"keyword\">Resume</span> <span class=\"keyword\">Next</span></span><br><span class=\"line\">   <span class=\"keyword\">Dim</span> n <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span> = <span class=\"number\">2</span> \\ n</span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Function</span></span><br></pre></td></tr></table></figure></p>\n<p>这个值有2行的过程动用了VB强大的语法杀手——<strong>On Error Resume</strong> Next，它将忽略所有异常，让代码紧接产生异常的语句继续执行下去，猜猜这个功能产生了多少IL指令？答案是<strong>50</strong>条！比普通的<strong>On Error</strong>还要长。其实现我就不多说了，和前面的On语句差不多。不过50这个数字似乎提醒了大家，不要在程序里偷懒使用On Error处理异常，这样产生的代价是不可接受的。</p>\n<p>最后一个例子是VB.NET的When语句，它可以实现对Catch部分的过滤：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Function</span> F1() <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span></span><br><span class=\"line\">   <span class=\"keyword\">Dim</span> n <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span> = <span class=\"number\">0</span></span><br><span class=\"line\">   <span class=\"keyword\">Try</span></span><br><span class=\"line\">      <span class=\"keyword\">Dim</span> m <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span> = <span class=\"number\">2</span> \\ n</span><br><span class=\"line\">   <span class=\"keyword\">Catch</span> ex <span class=\"keyword\">As</span> Exception <span class=\"keyword\">When</span> n = <span class=\"number\">0</span></span><br><span class=\"line\">      MsgBox(ex.Message)</span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Try</span></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Function</span></span><br></pre></td></tr></table></figure></p>\n<p>里面的When语句进行了对变量n的判断，仅当<strong>n = 0</strong>的时候才进入处理部分。</p>\n<p>听到“过滤”两个字，我们已经猜出，它是用try…filter来实现的。没错。这里的filter主要是进行ex是否是Exception型，n是否等于零等，当过滤成功，就会转移到异常处理段进行处理。这次VB生成的代码要比On Error语句规则得多，结构相当清晰。</p>\n<p>本次我们还借助On Error语句和When语句了解到try filter结构，它是C#不能生成的，因此，我发现它不能被常见的反编译器反编译（因为反编译器的编写者只知道C#，呵呵）。而且用了On Error后程序结构变得异常混乱，这在产生负面作用的时候，是不是能够变相起到保护我们代码的作用呢？</p>\n<p>（九）实例访问共享成员</p>\n<p>大家都知道静态成员在VB中叫做共享成员，虽然刚接受起来有点别扭，但“共享成员”的确是名副其实的：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Class</span> Class1</span><br><span class=\"line\">   <span class=\"keyword\">Public</span> <span class=\"keyword\">Shared</span> i <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span></span><br><span class=\"line\">   <span class=\"comment\">' Other none-shared members</span></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Class</span></span><br></pre></td></tr></table></figure></p>\n<p>不但像在C#中那样，可以用Class1.i访问共享成员i，还可以用实例变量来访问:<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Dim</span> c1 <span class=\"keyword\">As</span> <span class=\"keyword\">New</span> Class1</span><br><span class=\"line\">c1.i = <span class=\"number\">100</span></span><br></pre></td></tr></table></figure></p>\n<p>就像i是c1的成员一样！当然只有一个i，任何实例去修改i的值都将导致所有i的值改变（因为其实只有一个）。甚至Me和MyClass也可以访问共享成员。<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Me</span>.i = <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">MyClass</span>.i = <span class=\"number\">100</span></span><br></pre></td></tr></table></figure></p>\n<p>这在C#中是不可能做到的，一个纯正的C#程序员看到这些代码一定会觉得匪夷所思。为了揭示它的工作原理，我们可以做下列实验：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Dim</span> c1 <span class=\"keyword\">As</span> Class1</span><br><span class=\"line\">c1.i = <span class=\"number\">100</span></span><br></pre></td></tr></table></figure></p>\n<p>注意，这里的c1为Nothing!，即使是Nothing的变量也可以访问共享成员，而且不会出错。接下来我们实验更极端的情况：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Dim</span> o <span class=\"keyword\">As</span> <span class=\"built_in\">Object</span> = <span class=\"keyword\">New</span> Class1</span><br><span class=\"line\">o.i = <span class=\"number\">100</span></span><br></pre></td></tr></table></figure></p>\n<p>结果——失败，不能通过后期绑定访问共享成员。现在结果已经很明显，只有在VB明确了解对象类型的情况下，才能使用实例访问共享成员，VB会自动判断类型，然后将所有对共享成员访问的语句改写成<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class1.i = <span class=\"number\">100</span></span><br></pre></td></tr></table></figure></p>\n<p>这样的语法。Delphi也支持这一有趣的特征，而且李维在《Inside VCL》中将此说成Delphi.NET相对于.NET的扩展之一。</p>\n<blockquote>\n<p>“结果——失败，不能通过后期绑定访问共享成员”</p>\n</blockquote>\n<p>那只是编辑器不允许而已，语法结构上并没有错！将Option Strict 设为 off 就不会有错误提示。正在从无知迈向菜鸟…</p>\n","excerpt":"","more":"<p>VB.net能够实现很多C#不能做到的功能，如<strong>When</strong>语句、<strong>Optional</strong>参数、局部<strong>Static</strong>变量、对象实例访问静态方法、<strong>Handles</strong>绑定事件、<strong>On Error</strong>处理异常、<strong>Object</strong>直接后期绑定等等。VB和C#同属.net的语言，编译出来的是同样的CIL，但为什么VB支持很多有趣的特性呢。我们一起来探究一下。</p>\n<h3 id=\"局部静态变量\"><a href=\"#局部静态变量\" class=\"headerlink\" title=\"局部静态变量\"></a>局部静态变量</h3><p>VB支持用<strong>Static</strong>关键字声明局部变量，这样在过程结束的时候可以保持变量的数值：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Sub</span> Test1()</span><br><span class=\"line\">   <span class=\"keyword\">Static</span> i <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span></span><br><span class=\"line\">   i += <span class=\"number\">1</span>  <span class=\"comment\">' 实现一个过程调用计数器</span></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br></pre></td></tr></table></figure></p>\n<p>我们实现了一个简单的过程计数器。每调用一次Test，计数器的数值就增加1。其实还有很多情况我们希望保持变量的数值。而C#的static是不能用在过程内部的。因此要实现过程计数器，我们必须声明一个类级别的变量。这样做明显不如VB好。因为无法防止其他过程修改计数器变量。这就和对象封装一个道理，本来应该是一个方法的局部变量，现在我要被迫把它独立出来，显然是不好的设计。那么VB是怎么生成局部静态变量的呢？将上述代码返汇编，我们可以清楚地看到在VB生成的CIL中，i不是作为局部变量，而是作为类的Field出现的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.field <span class=\"keyword\">private</span> specialname int32 $STATIC$Test1$<span class=\"number\">2001</span>$i</span><br></pre></td></tr></table></figure>\n<p>也就是说，i被改名作为一个类的字段，但被冠以specialname。在代码中试图访问$STATIC$Test1$2001$i是不可能的，因为它不是一个有效的标识符。但是在IL中，将这个变量加一的代码却与一般的类字段完全一样，是通过ldfld加载的。我觉得这个方法十分聪明，把静态变量变成生命周期一样的类字段，但是又由编译器来控制访问的权限，让它成为一个局部变量。同时也解释了VB为什么要用两个不同的关键字来声明静态变量——Static和Shared。</p>\n<p>由于局部静态变量的实质是类的字段，所以它和真正的局部变量还是有所不同的。比如在多线程条件下，对局部静态变量的访问就和访问字段相同。</p>\n<h3 id=\"MyClass关键字\"><a href=\"#MyClass关键字\" class=\"headerlink\" title=\"MyClass关键字\"></a>MyClass关键字</h3><p>VB.net支持一项很有意思的功能——MyClass。大部分人使用MyClass可能仅限于调用本类其他构造函数时。其实MyClass可以产生一些很独特的用法。MyClass永远按类的成员为不可重写的状态进行调用，即当类的方法被重写后，用MyClass仍能得到自身的版本。下面这个例子和VB帮助中所举的例子非常相似<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Class</span> MyClassBase</span><br><span class=\"line\">   <span class=\"keyword\">Protected</span> <span class=\"keyword\">Overridable</span> <span class=\"keyword\">Sub</span> Greeting()</span><br><span class=\"line\">      Console.WriteLine(<span class=\"string\">\"Hello form Base\"</span>)</span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">Public</span> <span class=\"keyword\">Sub</span> UseMe()</span><br><span class=\"line\">      <span class=\"keyword\">Me</span>.Greeting()</span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">Public</span> <span class=\"keyword\">Sub</span> UseMyClass()</span><br><span class=\"line\">      <span class=\"keyword\">MyClass</span>.Greeting()</span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Class</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Class</span> MyClassSub</span><br><span class=\"line\">   <span class=\"keyword\">Inherits</span> MyClassBase</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">Protected</span> <span class=\"keyword\">Overrides</span> <span class=\"keyword\">Sub</span> Greeting()</span><br><span class=\"line\">      Console.WriteLine(<span class=\"string\">\"Hello form Sub\"</span>)</span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Class</span></span><br></pre></td></tr></table></figure></p>\n<p>我们用一段代码来测试：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Dim</span> o <span class=\"keyword\">As</span> MyClassBase = <span class=\"keyword\">New</span> MyClassSub()</span><br><span class=\"line\"></span><br><span class=\"line\">o.UseMe()</span><br><span class=\"line\">o.UseMyClass()</span><br></pre></td></tr></table></figure></p>\n<p>结果是UseMe执行了子类的版本，而UseMyClass还是执行了基类本身的版本，尽管这是一个虚拟方法。观其IL，可以看到其简单的实现原理：</p>\n<p>Me用的调用指令是callvirt</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IL_0001: callvirt  instance <span class=\"keyword\">void</span> App1.MyClassBase::Greeting()</span><br></pre></td></tr></table></figure>\n<p>而MyClass调用的是call<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IL_0001:  call     instance <span class=\"keyword\">void</span> App1.MyClassBase::Greeting()</span><br></pre></td></tr></table></figure></p>\n<p>奇怪的是，如此简单的一个功能，我竟然无法用C#实现，C#怎样也不允许我按非虚函数的方式调用一个虚函数。C++可以用类名::方法名的方式访问自身版本的函数，但C#的类名只能用来访问静态的成员。这真是C#一个奇怪的限制。</p>\n<h3 id=\"Handles和WithEvents\"><a href=\"#Handles和WithEvents\" class=\"headerlink\" title=\"Handles和WithEvents\"></a>Handles和WithEvents</h3><p>VB除了可以用C#那样的方法来处理事件响应以外，还有从VB5继承下来的独特的事件处理方式——WithEvents。</p>\n<p>我喜欢称这种事件处理方式为静态的事件处理，书写响应事件的方法时就已经决定该方法响应的是哪一个事件，而C#则是在代码中绑定事件的。比如下面这个最简单的例子：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Class</span> HandlerClass</span><br><span class=\"line\">   <span class=\"keyword\">Public</span> <span class=\"keyword\">WithEvents</span> MyObj <span class=\"keyword\">As</span> EventClass</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">Private</span> <span class=\"keyword\">Sub</span> MyObj_MyEvent(<span class=\"keyword\">ByVal</span> sender <span class=\"keyword\">As</span> <span class=\"built_in\">Object</span>, <span class=\"keyword\">ByVal</span> e <span class=\"keyword\">As</span> System.EventArgs) <span class=\"keyword\">Handles</span> MyObj.MyEvent</span><br><span class=\"line\">      MsgBox(<span class=\"string\">\"hello\"</span>)</span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">Public</span> <span class=\"keyword\">Sub</span> <span class=\"keyword\">New</span>()</span><br><span class=\"line\">      MyObj = <span class=\"keyword\">New</span> EventClass</span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Class</span></span><br></pre></td></tr></table></figure></p>\n<p>代码中用到的EventClass是这样的：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Class</span> EventClass</span><br><span class=\"line\">   <span class=\"keyword\">Public</span> <span class=\"keyword\">Event</span> MyEvent <span class=\"keyword\">As</span> EventHandler</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">Protected</span> <span class=\"keyword\">Overridable</span> <span class=\"keyword\">Sub</span> OnMyEvent(<span class=\"keyword\">ByVal</span> e <span class=\"keyword\">As</span> EventArgs)</span><br><span class=\"line\">      <span class=\"keyword\">RaiseEvent</span> MyEvent(<span class=\"keyword\">Me</span>, e)</span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">Public</span> <span class=\"keyword\">Sub</span> Test()</span><br><span class=\"line\">      OnMyEvent(<span class=\"keyword\">New</span> EventArgs)</span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Class</span></span><br></pre></td></tr></table></figure></p>\n<p>我们来复习一下，这段代码隐式地给EventClass编写了两个方法——Add_MyEvent(EventHandler)和Remove_MyEvent(EventHandler)，实际上任何使用事件的上下文都是通过调用这两个方法来绑定事件和解除绑定的。C#还允许你书写自己的事件绑定/解除绑定的代码。</p>\n<p>那么WithEvents是怎么工作的呢？VB.net的编译器在编译时自动将<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">WithEvents</span> MyObj <span class=\"keyword\">As</span> EventClass</span><br></pre></td></tr></table></figure></p>\n<p>翻译成下面这个过程：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Private</span> _MyObj <span class=\"keyword\">As</span> EventClass</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Property</span> MyObj() <span class=\"keyword\">As</span> EventClass</span><br><span class=\"line\">    <span class=\"keyword\">Get</span></span><br><span class=\"line\">        <span class=\"keyword\">Return</span> _MyObj</span><br><span class=\"line\">    <span class=\"keyword\">End</span> <span class=\"keyword\">Get</span></span><br><span class=\"line\">    <span class=\"keyword\">Set</span>(<span class=\"keyword\">ByVal</span> Value <span class=\"keyword\">As</span> EventClass)</span><br><span class=\"line\">        <span class=\"keyword\">If</span> <span class=\"keyword\">Not</span> (<span class=\"keyword\">Me</span>._MyObj <span class=\"keyword\">Is</span> <span class=\"literal\">Nothing</span>) <span class=\"keyword\">Then</span></span><br><span class=\"line\">            <span class=\"keyword\">RemoveHandler</span> _MyObj.MyEvent, <span class=\"keyword\">AddressOf</span> MyObj_MyEvent</span><br><span class=\"line\">        <span class=\"keyword\">End</span> <span class=\"keyword\">If</span></span><br><span class=\"line\">        <span class=\"keyword\">Me</span>._MyObj = Value</span><br><span class=\"line\">        <span class=\"keyword\">If</span> <span class=\"keyword\">Me</span>._MyObj <span class=\"keyword\">Is</span> <span class=\"literal\">Nothing</span> <span class=\"keyword\">Then</span> <span class=\"keyword\">Exit</span> <span class=\"keyword\">Property</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">AddHandler</span> _MyObj.MyEvent, <span class=\"keyword\">AddressOf</span> MyObj_MyEvent</span><br><span class=\"line\">    <span class=\"keyword\">End</span> <span class=\"keyword\">Set</span></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Property</span></span><br></pre></td></tr></table></figure></p>\n<p>由此可见，当对WithEvents变量赋值的时候，会自动触发这个属性以绑定事件。我们所用的大部分事件响应都是1对1的，即一个过程响应一个事件，所以这种WithEvents静态方法是非常有用的，它可以显著增强代码可读性，同时也让VB.net中的事件处理非常方便，不像C#那样离开了窗体设计器就必须手工绑定事件。</p>\n<p>不过在分析这段IL的时候，我也发现了VB.net在翻译时小小的问题，就是<strong>ldarg.0</strong>出现得过多，这是频繁使用Me或this的表现，所以我们在编码过程中一定要注意，除了使用到Me/this本身引用以外，使用它的成员时不要带上Me/this，比如<strong>Me.MyInt = 1</strong>就改成<strong>MyInt = 1</strong>，这样的小习惯会为你带来很大的性能收益。</p>\n<h3 id=\"类型转换运算符\"><a href=\"#类型转换运算符\" class=\"headerlink\" title=\"类型转换运算符\"></a>类型转换运算符</h3><p>在Visual Basic 2005中将加入一个新的运算符——TryCast，相当于C#的as运算符。我一直希望VB有这样一个运算符。VB目前的类型转换运算符主要有CType和DirectCast。他们的用法几乎一样。我详细比较了一下这两个运算符，得出以下结论：</p>\n<ul>\n<li>在转换成引用类型时，两者没有什么区别，都是直接调用castclass指令，除非重载了类型转换运算符CType。DirectCast运算符是不能重载的。</li>\n<li>转换成值类型时，CType会调用VB指定的类型转换函数（如果有的话），比如将String转换为Int32时，就会自动调用<strong>VisualBasic.CompilerServices.IntegerType.FromString</strong>，而将Object转换为Int32则会调用FromObject。其他数值类型转换为Int32时，CType也会调用类型本身的转换方法实施转换。DirectCast运算符则很简单，直接将对象拆箱成所需类型。</li>\n</ul>\n<p>所以在用于值类型时，CType没有DirectCast快速但可以支持更多的转换。在C#中，类型转换则为（type)运算符和as运算符。(type)运算符的工作方式与VB的DirectCast很相似，也是直接拆箱或castclass的，但是如果遇到支持的类型转换（如long到int），(type)运算符也会调用相应的转换方法，但不支持从String到int的转换。C#另一个运算符as则更加智能，它只要判断对象的运行实例能否转成目标类型，然后就可以省略castclass指令，直接按已知类型进行操作，而且编译器还可以自动对as进行优化，比如节省一个对象引用等。所以在将Object转换成所需的类型时，as是最佳选择。</p>\n<p>由于as有很多优点，Visual Basic 2005将这一特性吸收了过来，用TryCast运算符就可以获得和as一样的效果，而且语法与DirectCast或CType一样。</p>\n<h3 id=\"实现接口\"><a href=\"#实现接口\" class=\"headerlink\" title=\"实现接口\"></a>实现接口</h3><p>VB.net采用的实现接口的语法是VB5发明的Implements，这个实现接口的语法在当今主流语言中独一无二。比如我有两个接口：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Interface</span> Interface1</span><br><span class=\"line\">   <span class=\"keyword\">Sub</span> Test()</span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Interface</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Interface</span> Interface2</span><br><span class=\"line\">   <span class=\"keyword\">Sub</span> Test()</span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Interface</span></span><br></pre></td></tr></table></figure></p>\n<p>这两个接口有一个完全一样的成员Test。假设我需要用一个类同时实现两个接口会怎么样呢？先想想看，如果是Java，JScrip.NET这样的语言就只能用一个Test函数实现两个接口的Test成员。假如两个Test只是偶然重名，其内容必须要分别实现怎么办，于是一些解决接口重名的设计出现了……。在VB中，独特的Implements语句可以让你想怎么实现接口就怎么实现，比如下面的类Implementation用两个名字根本不一样的方法实现了两个接口。<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Class</span> Implementation</span><br><span class=\"line\">    <span class=\"keyword\">Implements</span> Interface1, Interface2</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">Public</span> <span class=\"keyword\">Sub</span> Hello() <span class=\"keyword\">Implements</span> Interface1.Test</span><br><span class=\"line\">    <span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">Private</span> <span class=\"keyword\">Sub</span> Hi() <span class=\"keyword\">Implements</span> Interface2.Test</span><br><span class=\"line\">    <span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Class</span></span><br></pre></td></tr></table></figure></p>\n<p>也就是说，VB允许用任意名字的函数实现接口中的成员，而且访问器可以是任意的，比如想用Public还是Private都可以。</p>\n<p>C#在处理重名成员上提供了显式实现（explicit implementation）的语法，其实现上述两个接口的语法为<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> Class1 : Interface1, Interface2 &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Class1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> Interface1.Test() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> Interface2.Test() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意这里，C#只能用接口名.成员名的名字来命名实现方法，而且访问器只能是private，不能公开显式实现的方法。</p>\n<p>在考察了IL以后，我发现.NET支持隐式实现和显式实现两种方式。其中隐式实现只要在类里面放一个与接口成员方法名字一样的方法即可——这一种VB不支持。而显式实现则在方法的描述信息里加入：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.override TestApp.Interface1::Test</span><br></pre></td></tr></table></figure></p>\n<p>无论是C#的显式实现还是VB的Implements语句都是这样的原理。也就是说.NET提供了换名实现接口成员的功能，但是只有VB将这个自由让给了用户，而其他语言还是采用了经典的语法。</p>\n<h3 id=\"默认属性和属性参数\"><a href=\"#默认属性和属性参数\" class=\"headerlink\" title=\"默认属性和属性参数\"></a>默认属性和属性参数</h3><p>在原先的VB6里，有一项奇特的功能——默认属性。在VB6中，对象的名称可以直接表示该对象的默认属性。比如TextBox的默认属性是Text，所以下面的代码<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Text1.<span class=\"keyword\">Text</span> = <span class=\"string\">\"Hello\"</span></span><br></pre></td></tr></table></figure></p>\n<p>就可以简化为<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Text1 = <span class=\"string\">\"Hello\"</span></span><br></pre></td></tr></table></figure></p>\n<p>这种简化给VB带来了很多麻烦，赋值运算就需要两个关键字——Let和Set，结果属性过程也需要Let和Set两种。而且这种特征在后期绑定的时候仍能工作。到了VB.NET，这项功能被大大限制了，现在只有带参数的属性才可以作为默认属性。如<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List1.Item(<span class=\"number\">0</span>) = <span class=\"string\">\"Hello\"</span></span><br></pre></td></tr></table></figure></p>\n<p>可以简化为<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List1(<span class=\"number\">0</span>) = <span class=\"string\">\"Hello\"</span></span><br></pre></td></tr></table></figure></p>\n<p>这种语法让有默认属性的对象看起来像是一个数组。那么VB怎么判断一个属性是否是默认属性呢？看下列代码<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Class</span> PropTest </span><br><span class=\"line\">   <span class=\"keyword\">Public</span> <span class=\"keyword\">Property</span> P1(<span class=\"keyword\">ByVal</span> index <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span>) <span class=\"keyword\">As</span> <span class=\"built_in\">String</span> </span><br><span class=\"line\">      <span class=\"keyword\">Get</span> </span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">End</span> <span class=\"keyword\">Get</span> </span><br><span class=\"line\">      <span class=\"keyword\">Set</span>(<span class=\"keyword\">ByVal</span> Value <span class=\"keyword\">As</span> <span class=\"built_in\">String</span>) </span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">End</span> <span class=\"keyword\">Set</span> </span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Property</span> </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">Default</span> <span class=\"keyword\">Public</span> <span class=\"keyword\">Property</span> P2(<span class=\"keyword\">ByVal</span> index <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span>) <span class=\"keyword\">As</span> <span class=\"built_in\">String</span> </span><br><span class=\"line\">      <span class=\"keyword\">Get</span> </span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">End</span> <span class=\"keyword\">Get</span> </span><br><span class=\"line\">      <span class=\"keyword\">Set</span>(<span class=\"keyword\">ByVal</span> Value <span class=\"keyword\">As</span> <span class=\"built_in\">String</span>) </span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">End</span> <span class=\"keyword\">Set</span> </span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Property</span> </span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Class</span></span><br></pre></td></tr></table></figure></p>\n<p>P1和P2两个属性基本上完全相同，唯一的不同是P2带有一个Default修饰符。反汇编这个类以后，可以发现两个属性完全相同，没有任何差异。但是PropTest类却被增加了一个自定义元属性<strong>System.Reflection.DefaultMemberAttribute</strong>。这个元属性指定的成员是InvokeMember所使用默认类型，也就是说后期绑定也可以使用默认属性。可是我试验将DefaultMember元属性手工添加到类型上却不能达到让某属性成为默认属性的功能。看来这项功能又是VB的一项“语法甜头”。但是，VB或C#的编译器对别人生成的类的默认属性应该只能通过<strong>DefaultMemberAttribute</strong>来判断，所以我将一个VB类只用<strong>DefaultMemberAttribute</strong>指定一个默认方法，不使用Default，然后将它编译以后给C#用，果然，C#将它识别为一个索引器（indexer）！</p>\n<p>既然说到了C#的索引器，我们就顺便来研究一下VB和C#属性方面的不同。刚才的实验结果是VB的默认属性在C#中就是索引器。但是VB仍然可以用属性的语法来访问默认属性，而C#只能用数组的语法访问索引器。更特别的是，VB可以创建不是默认属性，但是带有参数的属性，如上面例子里的P1，而C#则不支持带参数的属性，如果将VB编写的，含有带参数属性的类给C#用，C#会提示“属性不受该语言支持，请用get_XXX和set_XXX的语法访问”。也就是说，带参数的属性是CLR的一项功能，但不符合CLS（通用语言规范），因此就会出现跨语言的障碍。这也更加深了我们对CLS的认识——如果你希望让你的代码跨语言工作，请一定要注意符合CLS。</p>\n<h3 id=\"可选参数和按名传递\"><a href=\"#可选参数和按名传递\" class=\"headerlink\" title=\"可选参数和按名传递\"></a>可选参数和按名传递</h3><p>VB从4.0开始支持“可选参数”这一特性。就是说，函数或子程序的参数有些是可选的，调用的时候可以不输入。其实VB从1.0开始就有一些函数带有可选参数，只不过到了4.0才让用户自己开发这样的过程。在VB4里，可选参数可以不带默认值，而在VB.NET里，如果使用可选参数，则必须带有默认值。如<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Sub</span> TestOptional(<span class=\"keyword\">Optional</span> i <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span> = <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br></pre></td></tr></table></figure></p>\n<p>调用的时候，既可以写成TestOptional(2)，也可以写成TestOptional()，这种情况参数i自动等于1。如果过程有不止一个可选参数，则VB还提供一种简化操作的方法——按名传递参数。比如过程<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Sub</span> TestOptional(<span class=\"keyword\">Optional</span> i <span class=\"keyword\">As</span> Int32 = <span class=\"number\">1</span>, <span class=\"keyword\">Optional</span> j <span class=\"keyword\">As</span> Int32 = <span class=\"number\">1</span>, <span class=\"keyword\">Optional</span> k <span class=\"keyword\">As</span> Int32 = <span class=\"number\">1</span>) </span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Sub</span></span><br></pre></td></tr></table></figure></p>\n<p>如果只想指定k，让i和j使用默认值，就可以使用按名传递，如下<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestOptional(k := <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure></p>\n<p>而且这种方式不受参数表顺序的限制<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TestOptional(k := <span class=\"number\">2</span>, i := <span class=\"number\">3</span>, j := <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure></p>\n<p>这些的确是相当方便的功能，C#就不支持上述两个特性。我们看看它是怎样在IL级别实现的。上述第一个方法在IL中的定义为<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.<span class=\"function\">method <span class=\"keyword\">public</span> instance <span class=\"keyword\">void</span> <span class=\"title\">TestOptional</span><span class=\"params\">([opt] int32 i)</span> cil managed</span><br><span class=\"line\"></span>&#123;</span><br><span class=\"line\">.param [<span class=\"number\">1</span>] = int32(<span class=\"number\">0x00000001</span>)</span><br><span class=\"line\">.maxstack <span class=\"number\">8</span></span><br></pre></td></tr></table></figure></p>\n<p>可见，参数被加上了[opt]修饰符，而且.param指定了参数的默认值。这是只有VB能识别的内容，C#会跳过他们。在调用的时候，VB若发现参数被省略，则自动读取<em>.param</em>部分的默认值，并显式传递给过程。这一部分完全由编译器处理，而且没有任何性能损失，和手工传递所有参数是完全一样的。至于按名传递，VB会自动调整参数的顺序，其结果与传统方式的传递也没有任何的不同。这说明我们可以放心地使用这项便利。而且带有可选参数的过程拿到C#中，顶多变成不可选参数，也不会造成什么其他的麻烦。 </p>\n<p>PS.很多COM组件都使用了默认参数，而且有些过程的参数列表非常长，在VB里可以轻松地处理它们，而在C#中经常让开发者传参数传到吐血。 </p>\n<h3 id=\"On-Error语句和When语句\"><a href=\"#On-Error语句和When语句\" class=\"headerlink\" title=\"On Error语句和When语句\"></a>On Error语句和When语句</h3><p>本次讨论的是异常处理语句。VB.NET推荐使用<strong>Try…End Try</strong>块来进行结构化的异常处理，但是为了确保兼容性，它也从以前版本的BASIC中借鉴了On Error语句。其实On Error并不能算是VB的优点，因为使用它会破坏程序的结构，让带有异常处理的程序难以看懂和调试。但是我一直很惊叹于VB的工程师是怎样实现它的，因为On Error可以让异常的跳转变得很灵活，不像Try那样受到限制。首先看看Try是怎样实现的：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Function</span> F1() <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span></span><br><span class=\"line\">   <span class=\"keyword\">Try</span></span><br><span class=\"line\">      <span class=\"keyword\">Dim</span> n <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span> = <span class=\"number\">2</span> \\ n</span><br><span class=\"line\">   <span class=\"keyword\">Catch</span> ex <span class=\"keyword\">As</span> Exception</span><br><span class=\"line\">      MsgBox(ex.Message)</span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Try</span></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Function</span></span><br></pre></td></tr></table></figure></p>\n<p>这是最简单的异常处理程序，通过Reflector反汇编（如果用ILDasm，不要选择“展开try-catch”），可以发现整个过程被翻译成19条指令。留意这一句：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.<span class=\"keyword\">try</span> L_0000 <span class=\"keyword\">to</span> L_0006 <span class=\"keyword\">catch</span> Exception L_0006 <span class=\"keyword\">to</span> L_0022</span><br></pre></td></tr></table></figure></p>\n<p>这就是典型的try块，在catch处直接指定要捕获的异常，然后指定catch区的位置，非常清晰。还要留意这两句：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L_0007: <span class=\"keyword\">call</span> ProjectData.SetProjectError</span><br><span class=\"line\">L_001b: <span class=\"keyword\">call</span> ProjectData.ClearProjectError</span><br></pre></td></tr></table></figure></p>\n<p>可以看出，这两句是在catch块的开头和末尾。深入这两个过程我发现它是在为Err对象记录异常。看来使用Err也是语法甜头，性能苦头，凭空添加了这两句（幸好都不太复杂）。</p>\n<p>接下来我编写了一个与此功能类似的函数，用的是On语句处理异常：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Function</span> F2() <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span></span><br><span class=\"line\">   <span class=\"keyword\">On</span> <span class=\"keyword\">Error</span> <span class=\"keyword\">GoTo</span> CATCHBLOCK</span><br><span class=\"line\">   <span class=\"keyword\">Dim</span> n <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span> = <span class=\"number\">2</span> \\ n</span><br><span class=\"line\">   <span class=\"keyword\">Exit</span> <span class=\"keyword\">Function</span></span><br><span class=\"line\">   </span><br><span class=\"line\">CATCHBLOCK:</span><br><span class=\"line\">   MsgBox(Err.Description)</span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Function</span></span><br></pre></td></tr></table></figure></p>\n<p>这不比上一个过程复杂，但是反汇编以后，它的IL代码竟然有47条指令，刚才才19条啊！最主要的改变是try部分，现在它是这样：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.<span class=\"keyword\">try</span> L_0000 to L_0022 filter L_0022 L_0036 to L_0060</span><br></pre></td></tr></table></figure></p>\n<p>注意，catch不见了，而出现了filter。我从没在C#生成的IL中见过filter。我查询了Meta Data一节的文档，filter大概能够进行一些过滤，满足一定条件才进入处理异常的块中，本例来说，L_0022指令开始就是过滤器，它是：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L_0022: isinst Exception</span><br><span class=\"line\">L_0027: brfalse.s L_0033</span><br><span class=\"line\">L_0029: ldloc.s V_4</span><br><span class=\"line\">L_002b: brfalse.s L_0033</span><br><span class=\"line\">L_002d: ldloc<span class=\"number\">.3</span> </span><br><span class=\"line\">L_002e: brtrue.s L_0033</span><br><span class=\"line\">L_0030: ldc.i4<span class=\"number\">.1</span> </span><br><span class=\"line\">L_0031: br.s L_0034</span><br><span class=\"line\">L_0033: ldc.i4<span class=\"number\">.0</span> </span><br><span class=\"line\">L_0034: endfilter</span><br></pre></td></tr></table></figure></p>\n<p>endfilter就是异常处理部分代码的开始。而L0030之前的代码是过滤器的判断部分，<strong>V_4</strong>和<strong>V_3</strong>是VB自己加入保存错误代码的变量。在整个反汇编中，我发现设计成处理异常部分的代码在IL里其实也是在try块中，也就是说程序的结构已经不是规整的<strong>try…catch</strong>块，产生异常的语句和处理异常的语句在一起，而真正处理异常的指令是一大堆繁冗拖沓的跳转语句。</p>\n<p>下面看看我编写的第三个例子：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Function</span> F3() <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span></span><br><span class=\"line\">   <span class=\"keyword\">On</span> <span class=\"keyword\">Error</span> <span class=\"keyword\">Resume</span> <span class=\"keyword\">Next</span></span><br><span class=\"line\">   <span class=\"keyword\">Dim</span> n <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span> = <span class=\"number\">2</span> \\ n</span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Function</span></span><br></pre></td></tr></table></figure></p>\n<p>这个值有2行的过程动用了VB强大的语法杀手——<strong>On Error Resume</strong> Next，它将忽略所有异常，让代码紧接产生异常的语句继续执行下去，猜猜这个功能产生了多少IL指令？答案是<strong>50</strong>条！比普通的<strong>On Error</strong>还要长。其实现我就不多说了，和前面的On语句差不多。不过50这个数字似乎提醒了大家，不要在程序里偷懒使用On Error处理异常，这样产生的代价是不可接受的。</p>\n<p>最后一个例子是VB.NET的When语句，它可以实现对Catch部分的过滤：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Function</span> F1() <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span></span><br><span class=\"line\">   <span class=\"keyword\">Dim</span> n <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span> = <span class=\"number\">0</span></span><br><span class=\"line\">   <span class=\"keyword\">Try</span></span><br><span class=\"line\">      <span class=\"keyword\">Dim</span> m <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span> = <span class=\"number\">2</span> \\ n</span><br><span class=\"line\">   <span class=\"keyword\">Catch</span> ex <span class=\"keyword\">As</span> Exception <span class=\"keyword\">When</span> n = <span class=\"number\">0</span></span><br><span class=\"line\">      MsgBox(ex.Message)</span><br><span class=\"line\">   <span class=\"keyword\">End</span> <span class=\"keyword\">Try</span></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Function</span></span><br></pre></td></tr></table></figure></p>\n<p>里面的When语句进行了对变量n的判断，仅当<strong>n = 0</strong>的时候才进入处理部分。</p>\n<p>听到“过滤”两个字，我们已经猜出，它是用try…filter来实现的。没错。这里的filter主要是进行ex是否是Exception型，n是否等于零等，当过滤成功，就会转移到异常处理段进行处理。这次VB生成的代码要比On Error语句规则得多，结构相当清晰。</p>\n<p>本次我们还借助On Error语句和When语句了解到try filter结构，它是C#不能生成的，因此，我发现它不能被常见的反编译器反编译（因为反编译器的编写者只知道C#，呵呵）。而且用了On Error后程序结构变得异常混乱，这在产生负面作用的时候，是不是能够变相起到保护我们代码的作用呢？</p>\n<p>（九）实例访问共享成员</p>\n<p>大家都知道静态成员在VB中叫做共享成员，虽然刚接受起来有点别扭，但“共享成员”的确是名副其实的：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Public</span> <span class=\"keyword\">Class</span> Class1</span><br><span class=\"line\">   <span class=\"keyword\">Public</span> <span class=\"keyword\">Shared</span> i <span class=\"keyword\">As</span> <span class=\"built_in\">Integer</span></span><br><span class=\"line\">   <span class=\"comment\">' Other none-shared members</span></span><br><span class=\"line\"><span class=\"keyword\">End</span> <span class=\"keyword\">Class</span></span><br></pre></td></tr></table></figure></p>\n<p>不但像在C#中那样，可以用Class1.i访问共享成员i，还可以用实例变量来访问:<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Dim</span> c1 <span class=\"keyword\">As</span> <span class=\"keyword\">New</span> Class1</span><br><span class=\"line\">c1.i = <span class=\"number\">100</span></span><br></pre></td></tr></table></figure></p>\n<p>就像i是c1的成员一样！当然只有一个i，任何实例去修改i的值都将导致所有i的值改变（因为其实只有一个）。甚至Me和MyClass也可以访问共享成员。<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Me</span>.i = <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">MyClass</span>.i = <span class=\"number\">100</span></span><br></pre></td></tr></table></figure></p>\n<p>这在C#中是不可能做到的，一个纯正的C#程序员看到这些代码一定会觉得匪夷所思。为了揭示它的工作原理，我们可以做下列实验：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Dim</span> c1 <span class=\"keyword\">As</span> Class1</span><br><span class=\"line\">c1.i = <span class=\"number\">100</span></span><br></pre></td></tr></table></figure></p>\n<p>注意，这里的c1为Nothing!，即使是Nothing的变量也可以访问共享成员，而且不会出错。接下来我们实验更极端的情况：<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Dim</span> o <span class=\"keyword\">As</span> <span class=\"built_in\">Object</span> = <span class=\"keyword\">New</span> Class1</span><br><span class=\"line\">o.i = <span class=\"number\">100</span></span><br></pre></td></tr></table></figure></p>\n<p>结果——失败，不能通过后期绑定访问共享成员。现在结果已经很明显，只有在VB明确了解对象类型的情况下，才能使用实例访问共享成员，VB会自动判断类型，然后将所有对共享成员访问的语句改写成<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class1.i = <span class=\"number\">100</span></span><br></pre></td></tr></table></figure></p>\n<p>这样的语法。Delphi也支持这一有趣的特征，而且李维在《Inside VCL》中将此说成Delphi.NET相对于.NET的扩展之一。</p>\n<blockquote>\n<p>“结果——失败，不能通过后期绑定访问共享成员”</p>\n</blockquote>\n<p>那只是编辑器不允许而已，语法结构上并没有错！将Option Strict 设为 off 就不会有错误提示。正在从无知迈向菜鸟…</p>\n"},{"title":"关于NodeJS的单线程和异步IO","date":"2016-06-03T16:00:00.000Z","_content":"\n###### 引用文 摘自 IBM 刘欣 个人公众号：码农翻身\n\n美丽的七侠镇上有一条美食街，很多著名的饭店都开在这里，有老字号的Apache,PHP,最近几年火热的Ruby on Rail,还有那些重量级的餐饮集团Websphere,Weblogic等。这些饭店老板根据自己的实力，或多或少的雇佣了一些店小二来招待来客，这些小二干活都非常殷勤，没有一个偷懒耍滑，把顾客招待的舒舒服服，所以平日里饭馆运转的还不错，相安无事。\n但是随着《武林外传》的拍摄和播放，七侠镇旅游业大爆发，游客像潮水一样蜂拥而至，现有的店小二招待不过来了，到了饭点，每家的门前都排起了长队，游客们吃不上饭，个个怨声载道。看到这种情况，有些老板咬了咬牙，在人工费不断上涨的情况下，多雇了一些小二来帮忙，无奈总是赶不上顾客增长的速度。\n\n\n某一天有个美国老外来到七侠镇上旅游，也看到了吃不上饭的问题，他仔细分析了一番后发现了一个秘密：原来这些店都采用了同一套叫做“全程贴心服务”的模式，这个模式很有意思：\n\n>客人来了以后，马上有个店小二殷勤迎上去，带着找座位，点菜，给后厨下单\n>由于后厨做菜需要很长时间，店小二就在客人的旁边等着。\n>后厨一摇铃铛，大喊一声：上菜，店小二马上端到客人面前，然后站在一边等着客人吃完\n>客人说：结账，小二收钱，找钱，送客，迎接下一位。\n\n通常这个时候门口都排成了好几百人了！\n这个VIP服务实在是太贴心了！导致的结果很明显，饭店有几个店小二，就只能同时接待几个顾客。(当然，现实中是没有饭店是这么做的，否则就等着关门吧)\n\n老外一声不吭的回去了。\n\n过了几个月，美食一条街上出现了一个巨火无比的饭馆：**Node.js**\n虽然这个饭店中人满为患，可门口竟然没有排队的！\n更让人吃惊的是，这个店里声称：我只需要一个店小二！\n\nNode.js这个美国老外开的饭店确实只用了一个店小二，只不过这个小二干活的方式与众不同，他把所有的工作分为两类：\n> **A**.  马上就能干完的，例如迎客，点菜，找座，下单 等等\n> **B**.  需要等待别人干完才能干的活，例如上菜，结账 等\n\n+ 对 **A** 这个小二马上干活\n+ 对 **B** 店小二不会等待，他只是告诉别人说，你弄完了告诉我一声，我会接着干， 然后马上去做第一类工作\n\n\n>客人来了以后，这个店小二殷勤迎上去，带着找座位，点菜，给后厨下单\n由于后厨做菜需要很长时间，店小二闪电般的离开，去干别的活了，可能是迎客，点菜，找座等，总之是那些不用等待，迅速干完的活。\n后厨大喊一声：上菜，这个小二马上端到客人面前，然后离开，干其他活。\n客人说：结账，小二收钱，找钱，然后还是迅速闪人，干其他活。\n\n**这个唯一的店小二的能力被发挥到了极致，一刻不停，闪电般的在饭店里跑来跑去，因为老板明确的告诉他：不要等！**\n\nNode.js饭店的基础设施很强大，一旦那些耗时的操作完成，店小二立刻就能知道，飞奔过来马上接着干，如果遇到新的耗时的操作，小二毫不留情的离开。就这么简单，Node.js饭店火了，它同时接待客人的数量大大增加，而服务质量保持基本不变。\n\n这是我杜撰出来的一个不成熟的故事，帮助我来理解Node.js的特点：只用一个线程来处理所有请求，事件驱动编程。\n\n如果我们回过头来再以计算机的视角看一下会更加清楚：\n>店小二：线程\n顾客：http请求\n第一类工作(迎客，找座，下单):在服务器端的代码，能够快速执行\n后厨做菜，客人吃饭：耗时的I/O操作\n后厨大喊一声：上菜：这是一个长时间I/O操作完成的后所发出的事件\n客人说：结账：另外一个长时间I/O操作完成的后所发出的事件\n\n第二类工作(上菜，结账):同样是能快速执行的代码，但是他们需要等待那些耗时的I/O操作完成才能开始，确切的来说，收到了系统发出的事件以后才开始执行。在Node.js中实际上是在回调函数中来执行的\n\n下面是Node.js服务模式的伪代码：\n```javascript\n迎客();\n找座();\n下单();\n后厨处理(\"做菜完成事件\", function() {\n    上菜处理()；\n    客人吃饭(\"吃饭完成事件\", function() {\n        结账处理();\n        送客();\n    });\n});\n```\n\n需要引起注意的是：\n>**后厨处理()**这个函数接受两个参数，一个是事件名，另外一个是匿名的回调函数，事件发生，回调函数才会执行。**客人吃饭()**函数也是类似。\nNode.js使用的JavaScript作为服务器端的编程语言，这种回调的方式对于javascript程序员来说，是非常自然的事情，同时从代码的角度来讲，也显得非常清晰。另外Node.js使用Chrome的V8引擎来执行javascript,效率非常高\n\n\n我们能不能把代码写成这样？\n\n```javascript\n迎客();\n找座();\n下单();\n后厨处理(\"做菜完成事件\", function() {\n    上菜处理()；\n    客人吃饭(\"吃饭完成事件\", function() {\n    \t结账处理();\n    }\n});\n送客();\n```\n\n肯定不行！因为Node.js执行**后厨处理()**函数时，只是安插了一个匿名的回调函数在那里，并不会等待（_非阻塞I/O_），反而马上会执行**客人吃饭()**函数，所以上述的写法会引起逻辑上的错误：还没上菜就开始吃饭了！\n所以写惯了_**顺序阻塞I/O**_的我们需要改变一下思维方式，进入到事件驱动的世界中来。\n\n如果某个操作例如**上菜处理**是个CPU密集型的计算任务，Node.js那个唯一的线程就会忙于执行这个计算任务而被阻塞住，就无法响应其他的请求了，带来的后果很严重，整个服务器都无法响应了！这个时候，需要考虑把这样的代码进行异步处理，也变成node.js所擅长的事件驱动的方式。","source":"_posts/nodejs.md","raw":"---\ntitle: 关于NodeJS的单线程和异步IO\ntags: [nodejs,转载搬运]\ndate: 2016.06.04\n---\n\n###### 引用文 摘自 IBM 刘欣 个人公众号：码农翻身\n\n美丽的七侠镇上有一条美食街，很多著名的饭店都开在这里，有老字号的Apache,PHP,最近几年火热的Ruby on Rail,还有那些重量级的餐饮集团Websphere,Weblogic等。这些饭店老板根据自己的实力，或多或少的雇佣了一些店小二来招待来客，这些小二干活都非常殷勤，没有一个偷懒耍滑，把顾客招待的舒舒服服，所以平日里饭馆运转的还不错，相安无事。\n但是随着《武林外传》的拍摄和播放，七侠镇旅游业大爆发，游客像潮水一样蜂拥而至，现有的店小二招待不过来了，到了饭点，每家的门前都排起了长队，游客们吃不上饭，个个怨声载道。看到这种情况，有些老板咬了咬牙，在人工费不断上涨的情况下，多雇了一些小二来帮忙，无奈总是赶不上顾客增长的速度。\n\n\n某一天有个美国老外来到七侠镇上旅游，也看到了吃不上饭的问题，他仔细分析了一番后发现了一个秘密：原来这些店都采用了同一套叫做“全程贴心服务”的模式，这个模式很有意思：\n\n>客人来了以后，马上有个店小二殷勤迎上去，带着找座位，点菜，给后厨下单\n>由于后厨做菜需要很长时间，店小二就在客人的旁边等着。\n>后厨一摇铃铛，大喊一声：上菜，店小二马上端到客人面前，然后站在一边等着客人吃完\n>客人说：结账，小二收钱，找钱，送客，迎接下一位。\n\n通常这个时候门口都排成了好几百人了！\n这个VIP服务实在是太贴心了！导致的结果很明显，饭店有几个店小二，就只能同时接待几个顾客。(当然，现实中是没有饭店是这么做的，否则就等着关门吧)\n\n老外一声不吭的回去了。\n\n过了几个月，美食一条街上出现了一个巨火无比的饭馆：**Node.js**\n虽然这个饭店中人满为患，可门口竟然没有排队的！\n更让人吃惊的是，这个店里声称：我只需要一个店小二！\n\nNode.js这个美国老外开的饭店确实只用了一个店小二，只不过这个小二干活的方式与众不同，他把所有的工作分为两类：\n> **A**.  马上就能干完的，例如迎客，点菜，找座，下单 等等\n> **B**.  需要等待别人干完才能干的活，例如上菜，结账 等\n\n+ 对 **A** 这个小二马上干活\n+ 对 **B** 店小二不会等待，他只是告诉别人说，你弄完了告诉我一声，我会接着干， 然后马上去做第一类工作\n\n\n>客人来了以后，这个店小二殷勤迎上去，带着找座位，点菜，给后厨下单\n由于后厨做菜需要很长时间，店小二闪电般的离开，去干别的活了，可能是迎客，点菜，找座等，总之是那些不用等待，迅速干完的活。\n后厨大喊一声：上菜，这个小二马上端到客人面前，然后离开，干其他活。\n客人说：结账，小二收钱，找钱，然后还是迅速闪人，干其他活。\n\n**这个唯一的店小二的能力被发挥到了极致，一刻不停，闪电般的在饭店里跑来跑去，因为老板明确的告诉他：不要等！**\n\nNode.js饭店的基础设施很强大，一旦那些耗时的操作完成，店小二立刻就能知道，飞奔过来马上接着干，如果遇到新的耗时的操作，小二毫不留情的离开。就这么简单，Node.js饭店火了，它同时接待客人的数量大大增加，而服务质量保持基本不变。\n\n这是我杜撰出来的一个不成熟的故事，帮助我来理解Node.js的特点：只用一个线程来处理所有请求，事件驱动编程。\n\n如果我们回过头来再以计算机的视角看一下会更加清楚：\n>店小二：线程\n顾客：http请求\n第一类工作(迎客，找座，下单):在服务器端的代码，能够快速执行\n后厨做菜，客人吃饭：耗时的I/O操作\n后厨大喊一声：上菜：这是一个长时间I/O操作完成的后所发出的事件\n客人说：结账：另外一个长时间I/O操作完成的后所发出的事件\n\n第二类工作(上菜，结账):同样是能快速执行的代码，但是他们需要等待那些耗时的I/O操作完成才能开始，确切的来说，收到了系统发出的事件以后才开始执行。在Node.js中实际上是在回调函数中来执行的\n\n下面是Node.js服务模式的伪代码：\n```javascript\n迎客();\n找座();\n下单();\n后厨处理(\"做菜完成事件\", function() {\n    上菜处理()；\n    客人吃饭(\"吃饭完成事件\", function() {\n        结账处理();\n        送客();\n    });\n});\n```\n\n需要引起注意的是：\n>**后厨处理()**这个函数接受两个参数，一个是事件名，另外一个是匿名的回调函数，事件发生，回调函数才会执行。**客人吃饭()**函数也是类似。\nNode.js使用的JavaScript作为服务器端的编程语言，这种回调的方式对于javascript程序员来说，是非常自然的事情，同时从代码的角度来讲，也显得非常清晰。另外Node.js使用Chrome的V8引擎来执行javascript,效率非常高\n\n\n我们能不能把代码写成这样？\n\n```javascript\n迎客();\n找座();\n下单();\n后厨处理(\"做菜完成事件\", function() {\n    上菜处理()；\n    客人吃饭(\"吃饭完成事件\", function() {\n    \t结账处理();\n    }\n});\n送客();\n```\n\n肯定不行！因为Node.js执行**后厨处理()**函数时，只是安插了一个匿名的回调函数在那里，并不会等待（_非阻塞I/O_），反而马上会执行**客人吃饭()**函数，所以上述的写法会引起逻辑上的错误：还没上菜就开始吃饭了！\n所以写惯了_**顺序阻塞I/O**_的我们需要改变一下思维方式，进入到事件驱动的世界中来。\n\n如果某个操作例如**上菜处理**是个CPU密集型的计算任务，Node.js那个唯一的线程就会忙于执行这个计算任务而被阻塞住，就无法响应其他的请求了，带来的后果很严重，整个服务器都无法响应了！这个时候，需要考虑把这样的代码进行异步处理，也变成node.js所擅长的事件驱动的方式。","slug":"nodejs","published":1,"updated":"2016-06-03T19:25:19.124Z","_id":"cip02xkrf00066sv4ty5gsb0w","comments":1,"layout":"post","photos":[],"link":"","content":"<h6 id=\"引用文-摘自-IBM-刘欣-个人公众号：码农翻身\"><a href=\"#引用文-摘自-IBM-刘欣-个人公众号：码农翻身\" class=\"headerlink\" title=\"引用文 摘自 IBM 刘欣 个人公众号：码农翻身\"></a>引用文 摘自 IBM 刘欣 个人公众号：码农翻身</h6><p>美丽的七侠镇上有一条美食街，很多著名的饭店都开在这里，有老字号的Apache,PHP,最近几年火热的Ruby on Rail,还有那些重量级的餐饮集团Websphere,Weblogic等。这些饭店老板根据自己的实力，或多或少的雇佣了一些店小二来招待来客，这些小二干活都非常殷勤，没有一个偷懒耍滑，把顾客招待的舒舒服服，所以平日里饭馆运转的还不错，相安无事。<br>但是随着《武林外传》的拍摄和播放，七侠镇旅游业大爆发，游客像潮水一样蜂拥而至，现有的店小二招待不过来了，到了饭点，每家的门前都排起了长队，游客们吃不上饭，个个怨声载道。看到这种情况，有些老板咬了咬牙，在人工费不断上涨的情况下，多雇了一些小二来帮忙，无奈总是赶不上顾客增长的速度。</p>\n<p>某一天有个美国老外来到七侠镇上旅游，也看到了吃不上饭的问题，他仔细分析了一番后发现了一个秘密：原来这些店都采用了同一套叫做“全程贴心服务”的模式，这个模式很有意思：</p>\n<blockquote>\n<p>客人来了以后，马上有个店小二殷勤迎上去，带着找座位，点菜，给后厨下单<br>由于后厨做菜需要很长时间，店小二就在客人的旁边等着。<br>后厨一摇铃铛，大喊一声：上菜，店小二马上端到客人面前，然后站在一边等着客人吃完<br>客人说：结账，小二收钱，找钱，送客，迎接下一位。</p>\n</blockquote>\n<p>通常这个时候门口都排成了好几百人了！<br>这个VIP服务实在是太贴心了！导致的结果很明显，饭店有几个店小二，就只能同时接待几个顾客。(当然，现实中是没有饭店是这么做的，否则就等着关门吧)</p>\n<p>老外一声不吭的回去了。</p>\n<p>过了几个月，美食一条街上出现了一个巨火无比的饭馆：<strong>Node.js</strong><br>虽然这个饭店中人满为患，可门口竟然没有排队的！<br>更让人吃惊的是，这个店里声称：我只需要一个店小二！</p>\n<p>Node.js这个美国老外开的饭店确实只用了一个店小二，只不过这个小二干活的方式与众不同，他把所有的工作分为两类：</p>\n<blockquote>\n<p><strong>A</strong>.  马上就能干完的，例如迎客，点菜，找座，下单 等等<br><strong>B</strong>.  需要等待别人干完才能干的活，例如上菜，结账 等</p>\n</blockquote>\n<ul>\n<li>对 <strong>A</strong> 这个小二马上干活</li>\n<li>对 <strong>B</strong> 店小二不会等待，他只是告诉别人说，你弄完了告诉我一声，我会接着干， 然后马上去做第一类工作</li>\n</ul>\n<blockquote>\n<p>客人来了以后，这个店小二殷勤迎上去，带着找座位，点菜，给后厨下单<br>由于后厨做菜需要很长时间，店小二闪电般的离开，去干别的活了，可能是迎客，点菜，找座等，总之是那些不用等待，迅速干完的活。<br>后厨大喊一声：上菜，这个小二马上端到客人面前，然后离开，干其他活。<br>客人说：结账，小二收钱，找钱，然后还是迅速闪人，干其他活。</p>\n</blockquote>\n<p><strong>这个唯一的店小二的能力被发挥到了极致，一刻不停，闪电般的在饭店里跑来跑去，因为老板明确的告诉他：不要等！</strong></p>\n<p>Node.js饭店的基础设施很强大，一旦那些耗时的操作完成，店小二立刻就能知道，飞奔过来马上接着干，如果遇到新的耗时的操作，小二毫不留情的离开。就这么简单，Node.js饭店火了，它同时接待客人的数量大大增加，而服务质量保持基本不变。</p>\n<p>这是我杜撰出来的一个不成熟的故事，帮助我来理解Node.js的特点：只用一个线程来处理所有请求，事件驱动编程。</p>\n<p>如果我们回过头来再以计算机的视角看一下会更加清楚：</p>\n<blockquote>\n<p>店小二：线程<br>顾客：http请求<br>第一类工作(迎客，找座，下单):在服务器端的代码，能够快速执行<br>后厨做菜，客人吃饭：耗时的I/O操作<br>后厨大喊一声：上菜：这是一个长时间I/O操作完成的后所发出的事件<br>客人说：结账：另外一个长时间I/O操作完成的后所发出的事件</p>\n</blockquote>\n<p>第二类工作(上菜，结账):同样是能快速执行的代码，但是他们需要等待那些耗时的I/O操作完成才能开始，确切的来说，收到了系统发出的事件以后才开始执行。在Node.js中实际上是在回调函数中来执行的</p>\n<p>下面是Node.js服务模式的伪代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">迎客();</span><br><span class=\"line\">找座();</span><br><span class=\"line\">下单();</span><br><span class=\"line\">后厨处理(<span class=\"string\">\"做菜完成事件\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    上菜处理()；</span><br><span class=\"line\">    客人吃饭(<span class=\"string\">\"吃饭完成事件\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        结账处理();</span><br><span class=\"line\">        送客();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>需要引起注意的是：</p>\n<blockquote>\n<p><strong>后厨处理()</strong>这个函数接受两个参数，一个是事件名，另外一个是匿名的回调函数，事件发生，回调函数才会执行。<strong>客人吃饭()</strong>函数也是类似。<br>Node.js使用的JavaScript作为服务器端的编程语言，这种回调的方式对于javascript程序员来说，是非常自然的事情，同时从代码的角度来讲，也显得非常清晰。另外Node.js使用Chrome的V8引擎来执行javascript,效率非常高</p>\n</blockquote>\n<p>我们能不能把代码写成这样？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">迎客();</span><br><span class=\"line\">找座();</span><br><span class=\"line\">下单();</span><br><span class=\"line\">后厨处理(<span class=\"string\">\"做菜完成事件\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    上菜处理()；</span><br><span class=\"line\">    客人吃饭(<span class=\"string\">\"吃饭完成事件\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    \t结账处理();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">送客();</span><br></pre></td></tr></table></figure>\n<p>肯定不行！因为Node.js执行<strong>后厨处理()</strong>函数时，只是安插了一个匿名的回调函数在那里，并不会等待（<em>非阻塞I/O</em>），反而马上会执行<strong>客人吃饭()</strong>函数，所以上述的写法会引起逻辑上的错误：还没上菜就开始吃饭了！<br>所以写惯了<em><strong>顺序阻塞I/O</strong></em>的我们需要改变一下思维方式，进入到事件驱动的世界中来。</p>\n<p>如果某个操作例如<strong>上菜处理</strong>是个CPU密集型的计算任务，Node.js那个唯一的线程就会忙于执行这个计算任务而被阻塞住，就无法响应其他的请求了，带来的后果很严重，整个服务器都无法响应了！这个时候，需要考虑把这样的代码进行异步处理，也变成node.js所擅长的事件驱动的方式。</p>\n","excerpt":"","more":"<h6 id=\"引用文-摘自-IBM-刘欣-个人公众号：码农翻身\"><a href=\"#引用文-摘自-IBM-刘欣-个人公众号：码农翻身\" class=\"headerlink\" title=\"引用文 摘自 IBM 刘欣 个人公众号：码农翻身\"></a>引用文 摘自 IBM 刘欣 个人公众号：码农翻身</h6><p>美丽的七侠镇上有一条美食街，很多著名的饭店都开在这里，有老字号的Apache,PHP,最近几年火热的Ruby on Rail,还有那些重量级的餐饮集团Websphere,Weblogic等。这些饭店老板根据自己的实力，或多或少的雇佣了一些店小二来招待来客，这些小二干活都非常殷勤，没有一个偷懒耍滑，把顾客招待的舒舒服服，所以平日里饭馆运转的还不错，相安无事。<br>但是随着《武林外传》的拍摄和播放，七侠镇旅游业大爆发，游客像潮水一样蜂拥而至，现有的店小二招待不过来了，到了饭点，每家的门前都排起了长队，游客们吃不上饭，个个怨声载道。看到这种情况，有些老板咬了咬牙，在人工费不断上涨的情况下，多雇了一些小二来帮忙，无奈总是赶不上顾客增长的速度。</p>\n<p>某一天有个美国老外来到七侠镇上旅游，也看到了吃不上饭的问题，他仔细分析了一番后发现了一个秘密：原来这些店都采用了同一套叫做“全程贴心服务”的模式，这个模式很有意思：</p>\n<blockquote>\n<p>客人来了以后，马上有个店小二殷勤迎上去，带着找座位，点菜，给后厨下单<br>由于后厨做菜需要很长时间，店小二就在客人的旁边等着。<br>后厨一摇铃铛，大喊一声：上菜，店小二马上端到客人面前，然后站在一边等着客人吃完<br>客人说：结账，小二收钱，找钱，送客，迎接下一位。</p>\n</blockquote>\n<p>通常这个时候门口都排成了好几百人了！<br>这个VIP服务实在是太贴心了！导致的结果很明显，饭店有几个店小二，就只能同时接待几个顾客。(当然，现实中是没有饭店是这么做的，否则就等着关门吧)</p>\n<p>老外一声不吭的回去了。</p>\n<p>过了几个月，美食一条街上出现了一个巨火无比的饭馆：<strong>Node.js</strong><br>虽然这个饭店中人满为患，可门口竟然没有排队的！<br>更让人吃惊的是，这个店里声称：我只需要一个店小二！</p>\n<p>Node.js这个美国老外开的饭店确实只用了一个店小二，只不过这个小二干活的方式与众不同，他把所有的工作分为两类：</p>\n<blockquote>\n<p><strong>A</strong>.  马上就能干完的，例如迎客，点菜，找座，下单 等等<br><strong>B</strong>.  需要等待别人干完才能干的活，例如上菜，结账 等</p>\n</blockquote>\n<ul>\n<li>对 <strong>A</strong> 这个小二马上干活</li>\n<li>对 <strong>B</strong> 店小二不会等待，他只是告诉别人说，你弄完了告诉我一声，我会接着干， 然后马上去做第一类工作</li>\n</ul>\n<blockquote>\n<p>客人来了以后，这个店小二殷勤迎上去，带着找座位，点菜，给后厨下单<br>由于后厨做菜需要很长时间，店小二闪电般的离开，去干别的活了，可能是迎客，点菜，找座等，总之是那些不用等待，迅速干完的活。<br>后厨大喊一声：上菜，这个小二马上端到客人面前，然后离开，干其他活。<br>客人说：结账，小二收钱，找钱，然后还是迅速闪人，干其他活。</p>\n</blockquote>\n<p><strong>这个唯一的店小二的能力被发挥到了极致，一刻不停，闪电般的在饭店里跑来跑去，因为老板明确的告诉他：不要等！</strong></p>\n<p>Node.js饭店的基础设施很强大，一旦那些耗时的操作完成，店小二立刻就能知道，飞奔过来马上接着干，如果遇到新的耗时的操作，小二毫不留情的离开。就这么简单，Node.js饭店火了，它同时接待客人的数量大大增加，而服务质量保持基本不变。</p>\n<p>这是我杜撰出来的一个不成熟的故事，帮助我来理解Node.js的特点：只用一个线程来处理所有请求，事件驱动编程。</p>\n<p>如果我们回过头来再以计算机的视角看一下会更加清楚：</p>\n<blockquote>\n<p>店小二：线程<br>顾客：http请求<br>第一类工作(迎客，找座，下单):在服务器端的代码，能够快速执行<br>后厨做菜，客人吃饭：耗时的I/O操作<br>后厨大喊一声：上菜：这是一个长时间I/O操作完成的后所发出的事件<br>客人说：结账：另外一个长时间I/O操作完成的后所发出的事件</p>\n</blockquote>\n<p>第二类工作(上菜，结账):同样是能快速执行的代码，但是他们需要等待那些耗时的I/O操作完成才能开始，确切的来说，收到了系统发出的事件以后才开始执行。在Node.js中实际上是在回调函数中来执行的</p>\n<p>下面是Node.js服务模式的伪代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">迎客();</span><br><span class=\"line\">找座();</span><br><span class=\"line\">下单();</span><br><span class=\"line\">后厨处理(<span class=\"string\">\"做菜完成事件\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    上菜处理()；</span><br><span class=\"line\">    客人吃饭(<span class=\"string\">\"吃饭完成事件\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        结账处理();</span><br><span class=\"line\">        送客();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>需要引起注意的是：</p>\n<blockquote>\n<p><strong>后厨处理()</strong>这个函数接受两个参数，一个是事件名，另外一个是匿名的回调函数，事件发生，回调函数才会执行。<strong>客人吃饭()</strong>函数也是类似。<br>Node.js使用的JavaScript作为服务器端的编程语言，这种回调的方式对于javascript程序员来说，是非常自然的事情，同时从代码的角度来讲，也显得非常清晰。另外Node.js使用Chrome的V8引擎来执行javascript,效率非常高</p>\n</blockquote>\n<p>我们能不能把代码写成这样？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">迎客();</span><br><span class=\"line\">找座();</span><br><span class=\"line\">下单();</span><br><span class=\"line\">后厨处理(<span class=\"string\">\"做菜完成事件\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    上菜处理()；</span><br><span class=\"line\">    客人吃饭(<span class=\"string\">\"吃饭完成事件\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    \t结账处理();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">送客();</span><br></pre></td></tr></table></figure>\n<p>肯定不行！因为Node.js执行<strong>后厨处理()</strong>函数时，只是安插了一个匿名的回调函数在那里，并不会等待（<em>非阻塞I/O</em>），反而马上会执行<strong>客人吃饭()</strong>函数，所以上述的写法会引起逻辑上的错误：还没上菜就开始吃饭了！<br>所以写惯了<em><strong>顺序阻塞I/O</strong></em>的我们需要改变一下思维方式，进入到事件驱动的世界中来。</p>\n<p>如果某个操作例如<strong>上菜处理</strong>是个CPU密集型的计算任务，Node.js那个唯一的线程就会忙于执行这个计算任务而被阻塞住，就无法响应其他的请求了，带来的后果很严重，整个服务器都无法响应了！这个时候，需要考虑把这样的代码进行异步处理，也变成node.js所擅长的事件驱动的方式。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cip02xkqj00016sv4sj3qkkgk","tag_id":"cip02xkqw00026sv4xyf58scg","_id":"cip02xkr800046sv4no29lxc3"},{"post_id":"cip02xkqj00016sv4sj3qkkgk","tag_id":"cip02xkr200036sv4veqgbjpq","_id":"cip02xkra00056sv4kzcbx4cv"},{"post_id":"cip02xkrf00066sv4ty5gsb0w","tag_id":"cip02xkrj00076sv447z2a4o4","_id":"cip02xkrl00086sv4zfdioc5b"},{"post_id":"cip02xkrf00066sv4ty5gsb0w","tag_id":"cip02xkr200036sv4veqgbjpq","_id":"cip02xkrl00096sv4q1v5juik"}],"Tag":[{"name":"VB.NET","_id":"cip02xkqw00026sv4xyf58scg"},{"name":"转载搬运","_id":"cip02xkr200036sv4veqgbjpq"},{"name":"nodejs","_id":"cip02xkrj00076sv447z2a4o4"}]}}